{% extends "base.twig" %}

{% block title %}{{ door_name }} - Door Game{% endblock %}

{% block head %}
<link rel="stylesheet" href="/webdoors/terminal/assets/xterm.css">
<style>
    /* Keep nav/footer visible */
    .position-fixed {
        display: none !important;
    }

    html, body {
        margin: 0;
        padding: 0;
        height: 100%;
    }

    main.container {
        margin: 0 !important;
        padding: 0 !important;
        max-width: 100% !important;
        min-height: calc(100vh - 56px);
    }

    .container-fluid {
        padding: 0;
        margin: 0;
        position: relative;
        height: calc(100vh - 56px);
    }

    .terminal-controls {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
        padding: 5px 10px;
        background: #1a1a2e;
        height: 30px;
        z-index: 10;
    }

    #terminal-container {
        position: absolute;
        top: 30px;
        left: 0;
        right: 0;
        bottom: 0;
        background: #000;
        padding: 0;
        overflow: hidden;
    }
    #terminal-container {
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }
    #terminal-container .xterm {
        margin-top: 6px;
    }
    /* Force terminal surface to pure black */
    #terminal-container .xterm,
    #terminal-container .xterm-viewport,
    #terminal-container .xterm-screen,
    #terminal-container .xterm-screen canvas {
        background-color: #000 !important;
    }


    .connection-status {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 11px;
    }

    .status-disconnected {
        background-color: #dc3545;
        color: white;
    }

    .status-connecting {
        background-color: #ffc107;
        color: black;
    }

    .status-connected {
        background-color: #28a745;
        color: white;
    }

    .door-header {
        margin: 0;
        font-size: 0.9rem;
        justify-self: start;
    }

    #endSessionBtn {
        padding: 3px 10px;
        font-size: 12px;
        justify-self: end;
    }

    #connectionStatus {
        justify-self: center;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="terminal-controls">
        <h5 class="door-header" id="doorTitle">{{ door_name }}</h5>
        <div id="connectionStatus" class="connection-status status-disconnected">
            Status: Disconnected
        </div>
        <button id="endSessionBtn" class="btn btn-danger">End Session</button>
    </div>
    <div id="terminal-container"></div>
</div>

<script src="/webdoors/terminal/assets/xterm.js"></script>

<script>
let term = null;
const TERM_COLS = 80;
const TERM_ROWS = 25;
let socket = null;
let sessionId = null;
let wsPort = null;
const doorId = '{{ door_id }}';

// Initialize terminal
function initTerminal() {
    console.log('[INIT] Starting terminal initialization');
    const container = document.getElementById('terminal-container');
    console.log('[INIT] Container element:', container);
    console.log('[INIT] Container dimensions:', container.offsetWidth, 'x', container.offsetHeight);

    term = new Terminal({
        cursorBlink: true,
        cols: TERM_COLS,
        rows: TERM_ROWS,
        fontSize: 16,
        fontFamily: 'Courier New, monospace',
        scrollback: 0,
        theme: {
            background: '#000000',
            foreground: '#AAAAAA',
            cursor: '#00FF00',
            black: '#000000',
            red: '#AA0000',
            green: '#00AA00',
            yellow: '#AA5500',
            blue: '#0000AA',
            magenta: '#AA00AA',
            cyan: '#00AAAA',
            white: '#AAAAAA',
            brightBlack: '#555555',
            brightRed: '#FF5555',
            brightGreen: '#55FF55',
            brightYellow: '#FFFF55',
            brightBlue: '#5555FF',
            brightMagenta: '#FF55FF',
            brightCyan: '#55FFFF',
            brightWhite: '#FFFFFF'
        },
        convertEol: false
    });

    console.log('[INIT] Terminal created, opening in container');
    term.open(container);
    term.resize(TERM_COLS, TERM_ROWS);
    scheduleFixedTerminalSize();
    console.log('[INIT] Terminal opened');
    console.log('[INIT] Container children:', container.children.length);
    console.log('[INIT] Container innerHTML length:', container.innerHTML.length);

    // Handle terminal input
    term.onData((data) => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(data);
        }
    });

    term.onRender(() => {
        scheduleFixedTerminalSize();
    });
}

function updateStatus(message, state) {
    const statusDiv = document.getElementById('connectionStatus');
    statusDiv.textContent = 'Status: ' + message;
    statusDiv.className = 'connection-status status-' + state;
}

function launchDoorSession() {
    console.log('[LAUNCH] Launching door session for:', doorId);
    updateStatus('Launching...', 'connecting');
    term.writeln('\x1b[1;33mLaunching door game...\x1b[0m');

    const formData = new FormData();
    formData.append('door', doorId);

    return fetch('/api/door/launch', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        console.log('[LAUNCH] Launch response:', data);
        if (!data.success) {
            throw new Error(data.error || data.message || 'Failed to launch door');
        }
        return data.session;
    });
}

function connectToSession() {
    console.log('[CONNECT] connectToSession called, term exists:', !!term);

    // Get current session
    fetch('/api/door/session')
        .then(response => response.json())
        .then(data => {
            console.log('[CONNECT] Session data received:', data);

            if (!data.success || !data.session) {
                // No session exists, launch one
                console.log('[CONNECT] No session found, launching...');
                return launchDoorSession().then(session => {
                    data.session = session;
                    return data;
                });
            }
            return data;
        })
        .then(data => {
            if (!data.session) {
                updateStatus('Launch failed', 'disconnected');
                term.clear();
                term.writeln('\x1b[1;31mFailed to launch door session.\x1b[0m');
                return;
            }

            sessionId = data.session.session_id;
            wsPort = data.session.ws_port;
            const doorTitle = document.getElementById('doorTitle');
            if (doorTitle && data.session.door_name) {
                doorTitle.textContent = data.session.door_name;
                document.title = data.session.door_name + ' - Door Game';
            }

            // Clear terminal initialization artifacts
            console.log('[CONNECT] Clearing terminal');
            term.clear();

            // Connect to WebSocket
            updateStatus('Connecting...', 'connecting');
            term.writeln('\x1b[1;33mConnecting to ' + data.session.door_name + '...\x1b[0m');

            socket = new WebSocket('ws://localhost:' + wsPort);

            socket.onopen = () => {
                updateStatus('Connected', 'connected');
                term.writeln('\x1b[1;32mConnected!\x1b[0m');
                term.writeln('');
                term.focus();
            };

            let messageCount = 0;
            socket.onmessage = (event) => {
                messageCount++;

                // Debug: log received data
                if (event.data.length < 100) {
                    console.log('[WS recv #' + messageCount + ']', JSON.stringify(event.data));
                } else {
                    console.log('[WS recv #' + messageCount + ']', event.data.length, 'bytes');
                }

                // Check DOM before writing
                const containersBefore = document.querySelectorAll('#terminal-container').length;
                const blackBoxesBefore = document.querySelectorAll('[style*="background"][style*="000"]').length;

                term.write(event.data);

                // Check DOM after writing
                const containersAfter = document.querySelectorAll('#terminal-container').length;
                const blackBoxesAfter = document.querySelectorAll('[style*="background"][style*="000"]').length;

                if (containersBefore !== containersAfter || blackBoxesBefore !== blackBoxesAfter) {
                    console.warn('[DOM CHANGE] Containers:', containersBefore, '->', containersAfter,
                                 'Black boxes:', blackBoxesBefore, '->', blackBoxesAfter);
                }
            };

            socket.onclose = (event) => {
                updateStatus('Disconnected', 'disconnected');
                term.writeln('');
                term.writeln('\x1b[1;31m[Connection closed]\x1b[0m');
            };

            socket.onerror = (error) => {
                updateStatus('Connection error', 'disconnected');
                term.writeln('\x1b[1;31m[Connection error]\x1b[0m');
                console.error('WebSocket error:', error);
            };
        })
        .catch(error => {
            console.error('Failed to get session:', error);
            updateStatus('Error', 'disconnected');
            term.writeln('\x1b[1;31mFailed to connect: ' + error.message + '\x1b[0m');
        });
}

function endSession() {
    if (!sessionId) {
        return;
    }

    if (!confirm('Are you sure you want to end this door session?')) {
        return;
    }

    fetch('/api/door/end', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'session_id=' + encodeURIComponent(sessionId)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            if (socket) {
                socket.close();
            }
            window.location.href = '/games';
        } else {
            alert('Failed to end session');
        }
    })
    .catch(error => {
        console.error('Failed to end session:', error);
        alert('Error ending session');
    });
}

// Initialize on page load
window.addEventListener('DOMContentLoaded', () => {
    // Debug layout
    const controls = document.querySelector('.terminal-controls');
    console.log('[DEBUG] Controls bar height:', controls.offsetHeight);
    console.log('[DEBUG] Window height:', window.innerHeight);
    console.log('[DEBUG] calc(100vh - 35px) should be:', window.innerHeight - 35);

    initTerminal();
    connectToSession();
});

function setFixedTerminalSize() {
    if (!term || !term.element) {
        return;
    }
    const core = term._core;
    if (!core || !core._renderService || !core._renderService.dimensions) {
        return;
    }
    const dims = core._renderService.dimensions.css;
    if (!dims || !dims.cell) {
        return;
    }
    const width = Math.ceil(dims.cell.width * TERM_COLS);
    const height = Math.ceil(dims.cell.height * TERM_ROWS);
    term.element.style.width = width + 'px';
    term.element.style.height = height + 'px';
}

function scheduleFixedTerminalSize() {
    if (window.requestAnimationFrame) {
        window.requestAnimationFrame(setFixedTerminalSize);
    } else {
        setFixedTerminalSize();
    }
}

window.addEventListener('resize', () => {
    scheduleFixedTerminalSize();
});

// End session button
document.getElementById('endSessionBtn').addEventListener('click', endSession);

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (socket) {
        socket.close();
    }
});
</script>
{% endblock %}
