# DOSBox Door Bridge Proposal

**Status:** Draft Proposal
**Author:** AI-Generated (Claude Sonnet 4.5)
**Date:** 2026-02-10
**Version:** 1.0

**⚠️ NOTICE:** This is a draft proposal generated by AI and has not been reviewed for accuracy or feasibility. Implementation details may require significant revision based on testing and real-world constraints.

---

## Executive Summary

This proposal outlines an architecture for running classic DOS BBS door games in BinktermPHP through a server-side DOSBox bridge connected to web clients via xterm.js. This approach would enable hundreds of classic DOS door games (TradeWars 2002, Legend of the Red Dragon, Barren Realms Elite, etc.) to run in the modern web-based BBS environment without requiring native ports.

## Background

### The Door Game Era

Classic BBS door games were external programs that:
- Ran in DOS on the BBS server
- Communicated via serial ports (COM1, COM2, etc.)
- Used Fossil drivers (X00, BNU) for I/O abstraction
- Received user/session info via drop files (DOOR.SYS, DORINFO1.DEF)
- Provided text-based ANSI interfaces

### The Challenge

Modern BBS software like BinktermPHP runs on:
- 64-bit operating systems (no native 16-bit DOS support)
- Web-based clients (no serial ports)
- Multi-user concurrent sessions (no direct COM port access)

### The Solution

Bridge DOSBox (DOS emulator) to web clients through:
1. **DOSBox:** Emulates DOS environment and serial ports
2. **Fossil Bridge:** Virtual Fossil driver or TCP serial bridge
3. **WebSocket Server:** Real-time bidirectional communication
4. **xterm.js Client:** Browser-based terminal emulator

---

## Architecture Overview

### High-Level Architecture

```
┌─────────────────┐
│   Web Browser   │
│   ┌─────────┐   │
│   │xterm.js │   │ <- ANSI rendering, keyboard input
│   └────┬────┘   │
│        │         │
└────────┼─────────┘
         │ WebSocket (wss://)
         ▼
┌─────────────────────────────────────────┐
│         BinktermPHP Server              │
│  ┌───────────────────────────────────┐  │
│  │   WebSocket Handler (PHP/Node)    │  │
│  └──────────┬────────────────────────┘  │
│             │                            │
│  ┌──────────▼────────────────────────┐  │
│  │   DosBoxDoorManager (PHP)         │  │
│  │   - Session management            │  │
│  │   - Drop file generation          │  │
│  │   - Process lifecycle             │  │
│  └──────────┬────────────────────────┘  │
│             │                            │
│  ┌──────────▼────────────────────────┐  │
│  │   Fossil/Serial Bridge            │  │
│  │   - TCP Socket Server             │  │
│  │   - ANSI/DOS character handling   │  │
│  │   - Flow control emulation        │  │
│  └──────────┬────────────────────────┘  │
│             │ TCP Socket                │
│  ┌──────────▼────────────────────────┐  │
│  │   DOSBox Instance                 │  │
│  │   - Emulated DOS environment      │  │
│  │   - Virtual COM port (TCP mode)   │  │
│  │   - Mounted game directory        │  │
│  │   └──> DOS Door Game Executable   │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### Component Interaction Flow

**Session Start:**
1. User clicks "Play TradeWars 2002" in web interface
2. PHP creates door session, generates drop files
3. PHP spawns DOSBox with game configuration
4. TCP bridge socket opened on random high port
5. DOSBox connects virtual COM port to TCP bridge
6. WebSocket established between client and bridge
7. Game output flows: DOSBox → TCP → Bridge → WebSocket → xterm.js
8. User input flows: xterm.js → WebSocket → Bridge → TCP → DOSBox

**Session End:**
1. User exits game or timeout occurs
2. DOSBox process terminated
3. TCP bridge socket closed
4. WebSocket connection closed
5. Temporary files cleaned up
6. Session logged to database

---

## Directory Structure

BinktermPHP follows a structured approach to runtime data organization:

```
{BASEDIR}/
├── data/
│   ├── doors/                      # Door game files
│   │   ├── tw2002/                # TradeWars 2002
│   │   ├── lord/                  # Legend of the Red Dragon
│   │   └── bre/                   # Barren Realms Elite
│   ├── run/
│   │   └── door_sessions/         # Active session directories
│   │       ├── {session-id-1}/    # DOSBox config, drop files, temp data
│   │       └── {session-id-2}/
│   └── logs/
│       └── doors/                 # Door game logs
│           ├── sessions.log       # Session activity
│           ├── bridge-{pid}.log   # Bridge server logs
│           └── dosbox-{pid}.log   # DOSBox logs
```

**Key Paths:**
- `BASEDIR` is defined as `BINKTERMPHP_BASEDIR` constant
- All paths are relative to `BASEDIR` for portability
- Session directories are created per-session and cleaned up on exit
- Door game files are installed once and shared across sessions

**Git Configuration:**
Add to `.gitignore`:
```
# DOSBox door sessions and runtime data
data/run/door_sessions/
data/logs/doors/

# Door game files (typically installed separately)
data/doors/*/
!data/doors/.gitkeep
```

---

## Technical Implementation

### 1. DOSBox Configuration

**Serial Port Redirection:**

DOSBox supports TCP-based serial port emulation:

```ini
[serial]
# Redirect COM1 to TCP server
serial1=nullmodem server:127.0.0.1 port:5000
# Baud rate, parity (ignored but required by some games)
serial1=115200,n,8,1

[cpu]
# Optimize for door game typical speed
core=auto
cputype=pentium_slow
cycles=10000

[autoexec]
# Mount game directory
mount c {BASEDIR}/data/doors/tw2002
c:
# Set environment variables some doors expect
set DSZLOG=dszlog.txt
set NODE=1
# Run the door game
tw2002.exe
# Exit DOSBox when game exits
exit
```

**Generated Per-Session Config:**

```php
class DosBoxConfigGenerator
{
    public function generateConfig(
        string $gamePath,
        string $gameExe,
        int $tcpPort,
        int $nodeNumber,
        array $gameConfig
    ): string {
        return <<<CONF
[serial]
serial1=nullmodem server:127.0.0.1 port:{$tcpPort}

[cpu]
core=auto
cputype={$gameConfig['cpu_type'] ?? 'auto'}
cycles={$gameConfig['cycles'] ?? 10000}

[render]
aspect=true
scaler=normal2x

[dos]
# Use XMS for doors that need it
xms=true
ems=true

[autoexec]
mount c {$gamePath}
c:
set NODE={$nodeNumber}
set PCBNODE={$nodeNumber}
set WCNODEID={$nodeNumber}
{$gameExe}
exit
CONF;
    }
}
```

### 2. Drop File Generation

DOS doors expect user/session info in drop files:

**DOOR.SYS (PCBoard format):**
```
COM1:                    <- Comm port
9600                     <- Baud rate
8                        <- Parity
1                        <- Node number
Y                        <- Screen display
Y                        <- Printer toggle
Y                        <- Page bell
Y                        <- Caller alarm
John Doe                 <- User name
New York, NY             <- Location
555-1234                 <- Phone
555-1234                 <- Phone
PASSWORD                 <- Password (often left blank)
100                      <- Security level
120                      <- Time logged on (minutes)
60                       <- Time remaining (minutes)
GR                       <- Graphics mode
23                       <- Page length
N                        <- Expert mode
1,2,3,4,5,6,7            <- Conferences registered
7                        <- Conference active
01/01/2026               <- Expiration date
1                        <- User record number
Y                        <- Default protocol
0                        <- Total uploads
0                        <- Total downloads
0                        <- KB downloaded today
999999                   <- KB download limit
01/01/2026               <- Birthdate
C:\BINKTERM\DOORS        <- Path to user file
C:\BINKTERM\DOORS        <- Path to gen file
SYSOP                    <- Sysop name
BinktermPHP              <- System name
00:00                    <- Event time
Y                        <- Error-free connection
Y                        <- ANSI supported
Y                        <- Use record locking
14                       <- Default color
60                       <- Time limit
01/01/2026               <- Last new files scan
01:00                    <- Time of call
01:00                    <- Last time on
9999                     <- Max daily files
0                        <- Files downloaded today
0                        <- KB uploaded
0                        <- KB downloaded
Comment line             <- User comment
0                        <- Total doors opened
0                        <- Messages left
```

**DORINFO1.DEF (Generic format, simpler):**
```
BinktermPHP              <- BBS name
Sysop                    <- Sysop name
John                     <- User first name
Doe                      <- User last name
New York, NY             <- Location
10                       <- ANSI (1=yes, 0=no)
100                      <- Security level
60                       <- Time remaining (minutes)
0                        <- Fossil mode (-1=yes, 0=no)
```

**PHP Implementation:**

```php
class DropFileGenerator
{
    public function generateDoorSys(
        int $nodeNumber,
        User $user,
        int $timeRemaining,
        string $outputPath
    ): void {
        $lines = [
            "COM{$nodeNumber}:",
            '115200',
            '8',
            (string)$nodeNumber,
            'Y', 'Y', 'Y', 'Y',
            $user->real_name,
            $user->location ?? 'Unknown',
            '555-1234',
            '555-1234',
            '',  // Password (blank)
            (string)$user->security_level,
            '0',  // Time logged on
            (string)$timeRemaining,
            'GR', // Graphics mode (ANSI)
            '23', // Page length
            'N',  // Expert mode
            '1,2,3,4,5,6,7',
            '7',
            date('m/d/Y'),
            (string)$user->id,
            'Y',
            '0', '0', '0',
            '999999',
            $user->birthdate ?? '01/01/1970',
            '/tmp/binkterm',
            '/tmp/binkterm',
            Config::get('system.sysop_name', 'Sysop'),
            Config::get('system.name', 'BinktermPHP'),
            '00:00',
            'Y', 'Y', 'Y',
            '14',
            (string)$timeRemaining,
            date('m/d/Y'),
            date('H:i'),
            date('H:i'),
            '9999',
            '0', '0', '0',
            '',
            '0', '0'
        ];

        file_put_contents($outputPath . '/DOOR.SYS', implode("\r\n", $lines) . "\r\n");
    }

    public function generateDorinfoDef(
        User $user,
        int $timeRemaining,
        string $outputPath
    ): void {
        $names = explode(' ', $user->real_name, 2);
        $lines = [
            Config::get('system.name', 'BinktermPHP'),
            Config::get('system.sysop_name', 'Sysop'),
            $names[0] ?? 'User',
            $names[1] ?? '',
            $user->location ?? 'Unknown',
            '1',  // ANSI
            (string)$user->security_level,
            (string)$timeRemaining,
            '0'   // Not using fossil driver directly
        ];

        file_put_contents($outputPath . '/DORINFO1.DEF', implode("\r\n", $lines) . "\r\n");
    }
}
```

### 3. TCP/WebSocket Bridge Server

The bridge handles bidirectional communication between DOSBox TCP serial and WebSocket clients.

**Option A: PHP Socket Server (Simple):**

```php
class DoorBridgeServer
{
    private $tcpSocket;
    private $wsConnection;

    public function __construct(int $tcpPort)
    {
        // Listen on TCP for DOSBox connection
        $this->tcpSocket = stream_socket_server(
            "tcp://127.0.0.1:{$tcpPort}",
            $errno,
            $errstr
        );

        if (!$this->tcpSocket) {
            throw new \Exception("Failed to create TCP socket: {$errstr}");
        }
    }

    public function acceptDosBoxConnection(): void
    {
        $this->dosboxConn = stream_socket_accept($this->tcpSocket, -1);
        if (!$this->dosboxConn) {
            throw new \Exception("Failed to accept DOSBox connection");
        }

        stream_set_blocking($this->dosboxConn, false);
    }

    public function setWebSocketConnection($wsConn): void
    {
        $this->wsConnection = $wsConn;
    }

    public function bridge(): void
    {
        // Read from DOSBox TCP, forward to WebSocket
        $read = [$this->dosboxConn];
        $write = null;
        $except = null;

        if (stream_select($read, $write, $except, 0, 100000)) {
            $data = fread($this->dosboxConn, 8192);
            if ($data !== false && strlen($data) > 0) {
                // Send to WebSocket client
                $this->wsConnection->send($data);
            }
        }

        // WebSocket to DOSBox handled in WebSocket onMessage callback
    }

    public function sendToDosBox(string $data): void
    {
        fwrite($this->dosboxConn, $data);
    }

    public function close(): void
    {
        if ($this->dosboxConn) {
            fclose($this->dosboxConn);
        }
        if ($this->tcpSocket) {
            fclose($this->tcpSocket);
        }
    }
}
```

**Option B: Node.js Bridge (More Robust):**

```javascript
// scripts/door-bridge-server.js
const net = require('net');
const WebSocket = require('ws');

class DoorBridge {
    constructor(tcpPort, wsPort) {
        this.tcpPort = tcpPort;
        this.wsPort = wsPort;
        this.dosboxSocket = null;
        this.wsClient = null;

        // TCP server for DOSBox
        this.tcpServer = net.createServer((socket) => {
            console.log('DOSBox connected');
            this.dosboxSocket = socket;

            socket.on('data', (data) => {
                // Forward DOSBox output to WebSocket client
                if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {
                    this.wsClient.send(data);
                }
            });

            socket.on('close', () => {
                console.log('DOSBox disconnected');
                if (this.wsClient) {
                    this.wsClient.close();
                }
            });

            socket.on('error', (err) => {
                console.error('DOSBox socket error:', err);
            });
        });

        // WebSocket server for web client
        this.wsServer = new WebSocket.Server({ port: wsPort });

        this.wsServer.on('connection', (ws) => {
            console.log('Web client connected');
            this.wsClient = ws;

            ws.on('message', (data) => {
                // Forward user input to DOSBox
                if (this.dosboxSocket && !this.dosboxSocket.destroyed) {
                    this.dosboxSocket.write(data);
                }
            });

            ws.on('close', () => {
                console.log('Web client disconnected');
                if (this.dosboxSocket) {
                    this.dosboxSocket.end();
                }
            });

            ws.on('error', (err) => {
                console.error('WebSocket error:', err);
            });
        });
    }

    start() {
        this.tcpServer.listen(this.tcpPort, '127.0.0.1', () => {
            console.log(`TCP bridge listening on port ${this.tcpPort}`);
        });
        console.log(`WebSocket server listening on port ${this.wsPort}`);
    }

    stop() {
        if (this.dosboxSocket) {
            this.dosboxSocket.destroy();
        }
        if (this.wsClient) {
            this.wsClient.close();
        }
        this.tcpServer.close();
        this.wsServer.close();
    }
}

// CLI usage
const args = process.argv.slice(2);
const tcpPort = parseInt(args[0]) || 5000;
const wsPort = parseInt(args[1]) || 5001;

const bridge = new DoorBridge(tcpPort, wsPort);
bridge.start();

// Cleanup on exit
process.on('SIGINT', () => {
    console.log('Shutting down bridge...');
    bridge.stop();
    process.exit(0);
});
```

### 4. Door Session Manager

**PHP Session Management:**

```php
namespace BinktermPHP;

class DosBoxDoorManager
{
    private $db;
    private $baseDir;
    private $sessionDir;
    private $doorsDir;
    private $logsDir;

    public function __construct()
    {
        $this->baseDir = defined('BINKTERMPHP_BASEDIR') ? BINKTERMPHP_BASEDIR : __DIR__ . '/..';
        $this->sessionDir = $this->baseDir . '/data/run/door_sessions';
        $this->doorsDir = $this->baseDir . '/data/doors';
        $this->logsDir = $this->baseDir . '/data/logs';

        // Ensure directories exist
        $this->ensureDirectories();
    }

    private function ensureDirectories(): void
    {
        $dirs = [
            $this->sessionDir,
            $this->doorsDir,
            $this->logsDir . '/doors'
        ];

        foreach ($dirs as $dir) {
            if (!is_dir($dir)) {
                mkdir($dir, 0750, true);
            }
        }
    }

    public function launchDoor(
        string $doorId,
        User $user,
        int $timeLimit = 60
    ): DoorSession {
        // Generate unique session ID
        $sessionId = bin2hex(random_bytes(16));

        // Get door configuration
        $doorConfig = $this->getDoorConfig($doorId);
        if (!$doorConfig) {
            throw new \Exception("Door not found: {$doorId}");
        }

        // Create session directory
        $sessionPath = $this->sessionDir . '/' . $sessionId;
        mkdir($sessionPath, 0700, true);

        // Allocate ports
        $tcpPort = $this->allocatePort();
        $wsPort = $this->allocatePort();
        $nodeNumber = $this->allocateNode();

        // Generate drop files
        $dropGen = new DropFileGenerator();
        $dropGen->generateDoorSys($nodeNumber, $user, $timeLimit, $sessionPath);
        $dropGen->generateDorinfoDef($user, $timeLimit, $sessionPath);

        // Generate DOSBox config
        $configGen = new DosBoxConfigGenerator();
        $config = $configGen->generateConfig(
            $doorConfig['path'],
            $doorConfig['executable'],
            $tcpPort,
            $nodeNumber,
            $doorConfig
        );
        file_put_contents($sessionPath . '/dosbox.conf', $config);

        // Start bridge server (Node.js version)
        $bridgePid = $this->startBridge($tcpPort, $wsPort, $sessionId);

        // Start DOSBox
        $dosboxPid = $this->startDosBox($sessionPath, $doorConfig);

        // Record session in database
        $session = new DoorSession([
            'session_id' => $sessionId,
            'user_id' => $user->id,
            'door_id' => $doorId,
            'tcp_port' => $tcpPort,
            'ws_port' => $wsPort,
            'node_number' => $nodeNumber,
            'dosbox_pid' => $dosboxPid,
            'bridge_pid' => $bridgePid,
            'session_path' => $sessionPath,
            'started_at' => date('Y-m-d H:i:s'),
            'expires_at' => date('Y-m-d H:i:s', time() + $timeLimit * 60)
        ]);

        $this->saveSession($session);

        return $session;
    }

    private function startBridge(int $tcpPort, int $wsPort, string $sessionId): int
    {
        $logFile = $this->sessionDir . '/' . $sessionId . '/bridge.log';

        $cmd = sprintf(
            'node %s/scripts/door-bridge-server.js %d %d > %s 2>&1 & echo $!',
            BINKTERMPHP_BASEDIR,
            $tcpPort,
            $wsPort,
            escapeshellarg($logFile)
        );

        $pid = (int)shell_exec($cmd);
        if ($pid <= 0) {
            throw new \Exception("Failed to start bridge server");
        }

        return $pid;
    }

    private function startDosBox(string $sessionPath, array $doorConfig): int
    {
        $logFile = $sessionPath . '/dosbox.log';

        $cmd = sprintf(
            'dosbox -conf %s > %s 2>&1 & echo $!',
            escapeshellarg($sessionPath . '/dosbox.conf'),
            escapeshellarg($logFile)
        );

        $pid = (int)shell_exec($cmd);
        if ($pid <= 0) {
            throw new \Exception("Failed to start DOSBox");
        }

        return $pid;
    }

    public function terminateSession(string $sessionId): void
    {
        $session = $this->getSession($sessionId);
        if (!$session) {
            return;
        }

        // Kill processes
        if ($session->dosbox_pid) {
            posix_kill($session->dosbox_pid, SIGTERM);
        }
        if ($session->bridge_pid) {
            posix_kill($session->bridge_pid, SIGTERM);
        }

        // Clean up session directory
        $this->cleanupSession($session->session_path);

        // Update database
        $this->markSessionEnded($sessionId);
    }

    private function allocatePort(): int
    {
        // Find available port in range 15000-16000
        $minPort = 15000;
        $maxPort = 16000;

        for ($port = $minPort; $port <= $maxPort; $port++) {
            $sock = @fsockopen('127.0.0.1', $port, $errno, $errstr, 0.1);
            if (!$sock) {
                return $port; // Port is available
            }
            fclose($sock);
        }

        throw new \Exception("No available ports in range {$minPort}-{$maxPort}");
    }

    private function allocateNode(): int
    {
        // Find available node number (1-255)
        $stmt = $this->db->query(
            "SELECT node_number FROM door_sessions
             WHERE expires_at > NOW()
             ORDER BY node_number"
        );

        $usedNodes = array_column($stmt->fetchAll(), 'node_number');

        for ($node = 1; $node <= 255; $node++) {
            if (!in_array($node, $usedNodes)) {
                return $node;
            }
        }

        throw new \Exception("No available node numbers");
    }
}
```

### 5. Web Client Integration

**xterm.js Implementation:**

```javascript
// public_html/js/dosbox-door.js

class DosBoxDoorClient {
    constructor(sessionId, containerElement) {
        this.sessionId = sessionId;
        this.container = containerElement;
        this.term = null;
        this.socket = null;
        this.connected = false;
    }

    async connect() {
        // Get session info from API
        const response = await fetch(`/api/dosbox/session/${this.sessionId}`);
        const session = await response.json();

        if (!session.success) {
            throw new Error('Failed to get session info');
        }

        // Initialize xterm.js
        this.term = new Terminal({
            cursorBlink: true,
            cols: 80,
            rows: 25,
            fontSize: 14,
            fontFamily: 'IBM VGA, Courier New, monospace',
            theme: {
                background: '#000000',
                foreground: '#AAAAAA'
            }
        });

        // Add WebGL renderer for better performance
        const fitAddon = new FitAddon.FitAddon();
        this.term.loadAddon(fitAddon);

        // Open terminal in container
        this.term.open(this.container);
        fitAddon.fit();

        // Connect WebSocket
        const wsUrl = `ws://${window.location.hostname}:${session.ws_port}`;
        this.socket = new WebSocket(wsUrl);

        this.socket.onopen = () => {
            console.log('Connected to DOSBox door');
            this.connected = true;
            this.term.focus();
        };

        this.socket.onmessage = (event) => {
            // Write DOSBox output to terminal
            this.term.write(event.data);
        };

        this.socket.onclose = () => {
            console.log('Disconnected from DOSBox door');
            this.connected = false;
            this.term.write('\r\n\r\n[Connection closed]\r\n');
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.term.write('\r\n\r\n[Connection error]\r\n');
        };

        // Send keyboard input to DOSBox
        this.term.onData((data) => {
            if (this.connected) {
                this.socket.send(data);
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            fitAddon.fit();
        });
    }

    disconnect() {
        if (this.socket) {
            this.socket.close();
        }
        if (this.term) {
            this.term.dispose();
        }
    }
}

// Usage in WebDoor page
document.addEventListener('DOMContentLoaded', async () => {
    const sessionId = new URLSearchParams(window.location.search).get('session');
    if (!sessionId) {
        alert('No session ID provided');
        return;
    }

    const container = document.getElementById('terminal-container');
    const client = new DosBoxDoorClient(sessionId, container);

    try {
        await client.connect();
    } catch (error) {
        console.error('Failed to connect:', error);
        alert('Failed to connect to door game');
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        client.disconnect();
    });
});
```

**HTML Template:**

```html
<!-- templates/dosbox_door.twig -->
{% extends "base.twig" %}

{% block title %}{{ door_name }} - {{ parent() }}{% endblock %}

{% block content %}
<div class="dosbox-door-container">
    <div class="door-header">
        <h2><i class="fas fa-gamepad"></i> {{ door_name }}</h2>
        <button id="exitButton" class="btn btn-danger">
            <i class="fas fa-times"></i> Exit Game
        </button>
    </div>

    <div id="terminal-container" class="terminal-wrapper"></div>

    <div class="door-footer">
        <small class="text-muted">
            Time Remaining: <span id="timeRemaining">{{ time_limit }}</span> minutes
        </small>
    </div>
</div>
{% endblock %}

{% block scripts %}
<link rel="stylesheet" href="/vendor/xterm/xterm.css">
<script src="/vendor/xterm/xterm.js"></script>
<script src="/vendor/xterm/xterm-addon-fit.js"></script>
<script src="/js/dosbox-door.js"></script>

<script>
const sessionId = '{{ session_id }}';
const doorClient = new DosBoxDoorClient(sessionId, document.getElementById('terminal-container'));

doorClient.connect().catch((error) => {
    console.error('Connection failed:', error);
    alert('Failed to connect to game');
    window.location.href = '/webdoors';
});

// Exit button handler
document.getElementById('exitButton').addEventListener('click', () => {
    if (confirm('Are you sure you want to exit the game?')) {
        doorClient.disconnect();
        window.location.href = '/webdoors';
    }
});

// Time remaining countdown
let timeRemaining = {{ time_limit }};
setInterval(() => {
    timeRemaining--;
    document.getElementById('timeRemaining').textContent = timeRemaining;
    if (timeRemaining <= 0) {
        alert('Time expired!');
        doorClient.disconnect();
        window.location.href = '/webdoors';
    }
}, 60000);
</script>
{% endblock %}
```

---

## API Endpoints

### Launch Door Session

**POST /api/dosbox/launch**

Request:
```json
{
    "door_id": "tw2002",
    "time_limit": 60
}
```

Response:
```json
{
    "success": true,
    "session_id": "a1b2c3d4e5f6...",
    "ws_port": 15001,
    "tcp_port": 15000,
    "expires_at": "2026-02-10T15:30:00Z"
}
```

### Get Session Info

**GET /api/dosbox/session/{sessionId}**

Response:
```json
{
    "success": true,
    "session_id": "a1b2c3d4e5f6...",
    "door_id": "tw2002",
    "door_name": "TradeWars 2002",
    "ws_port": 15001,
    "started_at": "2026-02-10T14:30:00Z",
    "expires_at": "2026-02-10T15:30:00Z",
    "time_remaining": 45
}
```

### Terminate Session

**DELETE /api/dosbox/session/{sessionId}**

Response:
```json
{
    "success": true,
    "message": "Session terminated"
}
```

---

## Database Schema

```sql
-- Door game definitions
CREATE TABLE dosbox_doors (
    id SERIAL PRIMARY KEY,
    door_id VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    executable VARCHAR(100) NOT NULL,
    path VARCHAR(255) NOT NULL,
    config JSONB,
    enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Active door sessions
CREATE TABLE door_sessions (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(64) UNIQUE NOT NULL,
    user_id INTEGER REFERENCES users(id),
    door_id VARCHAR(50) REFERENCES dosbox_doors(door_id),
    node_number INTEGER,
    tcp_port INTEGER,
    ws_port INTEGER,
    dosbox_pid INTEGER,
    bridge_pid INTEGER,
    session_path VARCHAR(255),
    started_at TIMESTAMPTZ DEFAULT NOW(),
    ended_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ NOT NULL,
    exit_status VARCHAR(50),
    INDEX idx_expires (expires_at),
    INDEX idx_user (user_id),
    INDEX idx_door (door_id)
);

-- Session activity logs
CREATE TABLE door_session_logs (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(64) REFERENCES door_sessions(session_id),
    event_type VARCHAR(50),
    event_data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    INDEX idx_session (session_id)
);
```

---

## Resource Management

### Concurrent Session Limits

```php
class DoorResourceManager
{
    // System-wide limits
    const MAX_TOTAL_SESSIONS = 10;
    const MAX_USER_SESSIONS = 2;
    const MAX_DOOR_SESSIONS = 5;

    public function canLaunchSession(int $userId, string $doorId): bool
    {
        // Check total active sessions
        $totalSessions = $this->countActiveSessions();
        if ($totalSessions >= self::MAX_TOTAL_SESSIONS) {
            throw new \Exception('System at maximum capacity');
        }

        // Check user's active sessions
        $userSessions = $this->countUserSessions($userId);
        if ($userSessions >= self::MAX_USER_SESSIONS) {
            throw new \Exception('You already have the maximum number of active sessions');
        }

        // Check door-specific sessions
        $doorSessions = $this->countDoorSessions($doorId);
        if ($doorSessions >= self::MAX_DOOR_SESSIONS) {
            throw new \Exception('This game is at maximum capacity');
        }

        return true;
    }
}
```

### Session Cleanup Daemon

```php
#!/usr/bin/env php
<?php
// scripts/door_cleanup_daemon.php

require_once __DIR__ . '/../vendor/autoload.php';

use BinktermPHP\Database;
use BinktermPHP\DosBoxDoorManager;

$db = Database::getInstance()->getPdo();
$doorManager = new DosBoxDoorManager();

while (true) {
    echo "[" . date('Y-m-d H:i:s') . "] Running cleanup check...\n";

    // Find expired sessions
    $stmt = $db->query("
        SELECT session_id
        FROM door_sessions
        WHERE ended_at IS NULL
        AND expires_at < NOW()
    ");

    $expiredSessions = $stmt->fetchAll(PDO::FETCH_COLUMN);

    foreach ($expiredSessions as $sessionId) {
        echo "Terminating expired session: {$sessionId}\n";
        try {
            $doorManager->terminateSession($sessionId);
        } catch (\Exception $e) {
            echo "Error terminating session: " . $e->getMessage() . "\n";
        }
    }

    // Clean up orphaned processes
    $stmt = $db->query("
        SELECT session_id, dosbox_pid, bridge_pid
        FROM door_sessions
        WHERE ended_at IS NULL
    ");

    while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
        // Check if processes are still running
        $dosboxRunning = posix_kill($row['dosbox_pid'], 0);
        $bridgeRunning = posix_kill($row['bridge_pid'], 0);

        if (!$dosboxRunning || !$bridgeRunning) {
            echo "Cleaning up orphaned session: {$row['session_id']}\n";
            $doorManager->terminateSession($row['session_id']);
        }
    }

    // Sleep for 30 seconds
    sleep(30);
}
```

---

## Security Considerations

### 1. File System Sandboxing

```ini
# DOSBox config - restrict file access
[autoexec]
# Only mount specific game directory
mount c {BASEDIR}/data/doors/tw2002
# Block access to parent directories
c:
# Prevent CD to root or parent
set DIRCMD=/O
```

### 2. Resource Limits

```php
// Set process limits for DOSBox
$cmd = sprintf(
    'ulimit -t 3600 && ulimit -m 524288 && dosbox -conf %s',
    escapeshellarg($configPath)
);

// CPU time: 1 hour max
// Memory: 512MB max
```

### 3. Input Validation

```php
class DoorSecurityValidator
{
    public function validateDropFileData(User $user): void
    {
        // Sanitize user input that goes into drop files
        $user->real_name = preg_replace('/[^\w\s\-]/', '', $user->real_name);
        $user->location = preg_replace('/[^\w\s,\-]/', '', $user->location);

        // Prevent command injection via user fields
        if (strpos($user->real_name, '..') !== false) {
            throw new \Exception('Invalid characters in name');
        }
    }

    public function validateSessionPath(string $path): void
    {
        $realPath = realpath($path);
        $basePath = realpath($this->sessionDir);

        if (strpos($realPath, $basePath) !== 0) {
            throw new \Exception('Invalid session path');
        }
    }
}
```

### 4. Network Isolation

```javascript
// Bridge server binds only to localhost
this.tcpServer.listen(this.tcpPort, '127.0.0.1');  // Not 0.0.0.0
```

### 5. Session Authentication

```php
// Verify session ownership before allowing connection
public function validateSession(string $sessionId, int $userId): bool
{
    $stmt = $this->db->prepare("
        SELECT user_id FROM door_sessions
        WHERE session_id = ? AND ended_at IS NULL
    ");
    $stmt->execute([$sessionId]);
    $session = $stmt->fetch();

    return $session && $session['user_id'] === $userId;
}
```

---

## Door Game Integration

### Classic Door Game Examples

**TradeWars 2002:**
```json
{
    "door_id": "tw2002",
    "name": "TradeWars 2002",
    "executable": "tw2002.exe",
    "path": "{BASEDIR}/data/doors/tw2002",
    "config": {
        "cpu_type": "pentium_slow",
        "cycles": 10000,
        "requires_fossil": true,
        "multinode": true,
        "drop_file_type": "door.sys"
    }
}
```

**Legend of the Red Dragon:**
```json
{
    "door_id": "lord",
    "name": "Legend of the Red Dragon",
    "executable": "lord.exe",
    "path": "{BASEDIR}/data/doors/lord",
    "config": {
        "cpu_type": "386",
        "cycles": 5000,
        "requires_fossil": true,
        "multinode": true,
        "drop_file_type": "dorinfo1.def"
    }
}
```

**Barren Realms Elite:**
```json
{
    "door_id": "bre",
    "name": "Barren Realms Elite",
    "executable": "bre.exe",
    "path": "{BASEDIR}/data/doors/bre",
    "config": {
        "cpu_type": "386",
        "cycles": 3000,
        "requires_fossil": false,
        "multinode": true,
        "drop_file_type": "door.sys"
    }
}
```

### Installation Script

```bash
#!/bin/bash
# scripts/install_door.sh

DOOR_ID=$1
DOOR_ZIP=$2
DOOR_NAME=$3

if [ -z "$DOOR_ID" ] || [ -z "$DOOR_ZIP" ]; then
    echo "Usage: install_door.sh <door_id> <door_zip> [door_name]"
    exit 1
fi

BINKTERM_BASE="${BINKTERM_BASE:-/var/www/binkterm}"
DOORS_DIR="$BINKTERM_BASE/data/doors"
DOOR_PATH="$DOORS_DIR/$DOOR_ID"

# Create door directory
mkdir -p "$DOOR_PATH"

# Extract door files
unzip -q "$DOOR_ZIP" -d "$DOOR_PATH"

# Find main executable (common patterns)
MAIN_EXE=$(find "$DOOR_PATH" -maxdepth 1 -iname "*.exe" | head -n 1)
if [ -z "$MAIN_EXE" ]; then
    echo "Error: No .exe file found"
    exit 1
fi

MAIN_EXE=$(basename "$MAIN_EXE")

# Create config entry
php scripts/add_door_config.php "$DOOR_ID" "$MAIN_EXE" "$DOOR_NAME"

echo "Door installed: $DOOR_ID ($MAIN_EXE)"
echo "Path: $DOOR_PATH"
echo "Edit door config in admin panel to enable"
```

---

## Challenges and Solutions

### Challenge 1: DOS Character Encoding

**Problem:** DOS uses CP437 encoding, web clients use UTF-8.

**Solution:** Convert in bridge:
```javascript
const iconv = require('iconv-lite');

socket.on('data', (data) => {
    // Convert CP437 to UTF-8
    const utf8Data = iconv.decode(data, 'cp437');
    wsClient.send(utf8Data);
});

ws.on('message', (data) => {
    // Convert UTF-8 to CP437
    const cp437Data = iconv.encode(data, 'cp437');
    socket.write(cp437Data);
});
```

### Challenge 2: ANSI Color Codes

**Problem:** DOS ANSI may not render correctly in xterm.js.

**Solution:** xterm.js handles ANSI natively, but some tweaks help:
```javascript
this.term = new Terminal({
    convertEol: true,
    // IBM VGA font for authentic look
    fontFamily: 'IBM VGA, Perfect DOS VGA 437, Courier New',
    // DOS palette
    theme: {
        black: '#000000',
        red: '#AA0000',
        green: '#00AA00',
        yellow: '#AA5500',
        blue: '#0000AA',
        magenta: '#AA00AA',
        cyan: '#00AAAA',
        white: '#AAAAAA',
        brightBlack: '#555555',
        brightRed: '#FF5555',
        brightGreen: '#55FF55',
        brightYellow: '#FFFF55',
        brightBlue: '#5555FF',
        brightMagenta: '#FF55FF',
        brightCyan: '#55FFFF',
        brightWhite: '#FFFFFF'
    }
});
```

### Challenge 3: Timing and Performance

**Problem:** DOSBox emulation speed vs. network latency.

**Solution:**
- Tune DOSBox cycles per game
- Use WebSocket compression
- Buffer output for smoother rendering

```javascript
// WebSocket with compression
const ws = new WebSocket(url, {
    perMessageDeflate: true
});

// Buffer output
let outputBuffer = '';
let flushTimer = null;

socket.on('data', (data) => {
    outputBuffer += data.toString();

    if (!flushTimer) {
        flushTimer = setTimeout(() => {
            if (wsClient && wsClient.readyState === WebSocket.OPEN) {
                wsClient.send(outputBuffer);
            }
            outputBuffer = '';
            flushTimer = null;
        }, 50); // Flush every 50ms
    }
});
```

### Challenge 4: Multi-Node Games

**Problem:** Many doors support multiple simultaneous players (multi-node).

**Solution:**
- Each session gets unique node number
- Shared game data directory
- File locking for game state

```php
// Ensure unique node numbers
private function allocateNode(): int
{
    $stmt = $this->db->query("
        SELECT node_number FROM door_sessions
        WHERE door_id = ? AND ended_at IS NULL
        ORDER BY node_number
    ", [$doorId]);

    $usedNodes = array_column($stmt->fetchAll(), 'node_number');

    for ($node = 1; $node <= 255; $node++) {
        if (!in_array($node, $usedNodes)) {
            return $node;
        }
    }
}
```

### Challenge 5: Game State Persistence

**Problem:** Door games save state in files, need to persist across sessions.

**Solution:**
- Mount shared game data directory in DOSBox
- Separate user data from game files
- Backup game state periodically

```ini
[autoexec]
# Mount game files (read-only)
mount c {BASEDIR}/data/doors/tw2002 -t cdrom
# Mount data directory (read-write)
mount d {BASEDIR}/data/doors/tw2002/data
c:
tw2002.exe
```

---

## Alternative Approaches Considered

### 1. Direct Fossil Driver Bridge

**Pros:**
- Most authentic to original BBS architecture
- Better compatibility with doors expecting Fossil

**Cons:**
- Requires writing custom Fossil TSR
- Complex low-level DOS programming
- Harder to debug

**Verdict:** TCP serial bridge is simpler and equally functional.

### 2. DOSEMU Instead of DOSBox

**Pros:**
- Faster (less emulation overhead)
- Better DOS compatibility
- Native Linux integration

**Cons:**
- Linux-only (no Windows)
- More difficult to configure
- Security concerns (less sandboxing)

**Verdict:** DOSBox is more portable and secure.

### 3. Native Door Ports

**Pros:**
- No emulation overhead
- Modern code, easier to maintain
- Better performance

**Cons:**
- Few doors have been ported
- Significant development effort per door
- Loses authentic DOS experience

**Verdict:** Useful for select popular doors, but DOSBox bridge handles the long tail.

### 4. Pre-rendered Video Stream

**Pros:**
- Lower server resource usage
- Simpler client implementation

**Cons:**
- Input latency
- Poor quality for text
- Doesn't feel interactive

**Verdict:** Not suitable for text-based interactive games.

---

## Proof of Concept Plan

### Phase 1: Basic Bridge (Week 1)

**Goals:**
- Simple TCP-to-WebSocket bridge (Node.js)
- Manual DOSBox spawn
- xterm.js client with hardcoded connection

**Deliverables:**
- `scripts/door-bridge-server.js`
- `public_html/test/dosbox-poc.html`
- Test with simple DOS program (not a door)

### Phase 2: Drop File Generation (Week 2)

**Goals:**
- PHP drop file generators (DOOR.SYS, DORINFO1.DEF)
- Test with actual door game (LORD or similar)
- Verify door can read drop files

**Deliverables:**
- `src/DropFileGenerator.php`
- Test suite for drop file formats
- Working single-user door session

### Phase 3: Session Management (Week 3)

**Goals:**
- PHP session manager
- Port allocation
- Process lifecycle management
- Database schema

**Deliverables:**
- `src/DosBoxDoorManager.php`
- Database migration
- API endpoints for session control

### Phase 4: WebDoor Integration (Week 4)

**Goals:**
- Integrate with WebDoors system
- User interface for launching doors
- Session cleanup and timeout
- Multi-user support

**Deliverables:**
- WebDoor manifest for DOS door wrapper
- Admin interface for door configuration
- Full end-to-end working system

### Phase 5: Polish and Production (Week 5-6)

**Goals:**
- Error handling and recovery
- Performance tuning
- Security hardening
- Documentation
- Multiple door game testing

**Deliverables:**
- Production-ready implementation
- Admin documentation
- User documentation
- Security audit report

---

## Resource Requirements

### Server Requirements

**Hardware - Minimum per DOSBox instance:**
- CPU: 5-10% (one core)
- RAM: 50-100 MB
- Disk: 50 MB (temp session files)

**Hardware - For 10 concurrent sessions:**
- CPU: 1-2 cores dedicated
- RAM: 1 GB
- Disk: 500 MB temp space

**Software Dependencies:**

**Operating System:**
- Linux (Ubuntu 22.04 LTS or Debian 12 recommended)
- Windows Server 2019+ (alternative, less tested)
- macOS 12+ (development only)

**Core Components:**
- **DOSBox-X:** 2024.10.01 or newer (preferred)
  - Alternative: DOSBox SVN 0.74-3+
  - Installation: `apt-get install dosbox-x` or build from source
  - Repository: https://github.com/joncampbell123/dosbox-x

- **Node.js:** 20.x LTS (20.11.0 or newer)
  - Minimum: Node.js 18.x LTS
  - Installation: Via NodeSource or nvm
  - Repository: https://nodejs.org/

- **PHP:** 8.2 or 8.3
  - Minimum: PHP 8.1
  - Required extensions: `ext-sockets`, `ext-pcntl`, `ext-posix`
  - Installation: `apt-get install php8.2 php8.2-sockets`

**Node.js Packages (package.json):**
```json
{
  "dependencies": {
    "ws": "^8.16.0",
    "iconv-lite": "^0.6.3"
  },
  "devDependencies": {
    "@types/ws": "^8.5.10",
    "@types/node": "^20.11.0"
  }
}
```

**Frontend Libraries (CDN or npm):**
- **xterm.js:** ^5.3.0
- **xterm-addon-fit:** ^0.8.0
- **xterm-addon-webgl:** ^0.16.0 (optional, GPU rendering)
- **xterm-addon-web-links:** ^0.9.0 (optional, clickable URLs)

**Optional Production Tools:**
- **Supervisor:** 4.2.5+ (process management)
  - Installation: `apt-get install supervisor`
- **Nginx:** 1.24+ (reverse proxy for WebSockets)
  - Installation: `apt-get install nginx`
- **Screen/Tmux:** 4.9.0+/3.2+ (session management)
  - Installation: `apt-get install screen tmux`

### Development Time Estimate

- Basic bridge: 40 hours
- Drop files and session management: 40 hours
- WebDoor integration: 30 hours
- Testing and polish: 30 hours
- Documentation: 20 hours

**Total: ~160 hours (4 weeks full-time)**

---

## Installation Guide

### Step 1: Install System Dependencies (Ubuntu/Debian)

```bash
# Update package lists
sudo apt-get update

# Try to install DOSBox-X from package repository first
sudo apt-get install dosbox-x

# If DOSBox-X not available in repos, build from source (see below)
# Or install regular DOSBox as fallback
sudo apt-get install dosbox

# Install Node.js 20.x LTS
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt-get install -y nodejs

# Install PHP 8.2 with required extensions
sudo apt-get install php8.2 php8.2-cli php8.2-fpm \
    php8.2-sockets php8.2-pcntl php8.2-posix \
    php8.2-pgsql php8.2-mbstring

# Install optional production tools
sudo apt-get install supervisor nginx screen

# Verify installations
dosbox -version
node --version
npm --version
php --version
```

### Step 1b: Build DOSBox-X from Source (Optional)

**⚠️ Note:** These instructions have not been fully tested. Use at your own discretion.

If DOSBox-X is not available in your distribution's package repository, you can build it from source:

```bash
# Install build dependencies
sudo apt install automake gcc g++ make libncurses-dev nasm \
    libsdl2-dev libsdl2-net-dev libpcap-dev libslirp-dev fluidsynth \
    libfluidsynth-dev libavformat-dev libavcodec-dev libswscale-dev \
    libfreetype-dev libxkbfile-dev libxrandr-dev libglu1-mesa-dev

# Clone DOSBox-X repository
git clone https://github.com/joncampbell123/dosbox-x.git
cd dosbox-x

# Build DOSBox-X
./build

# Install system-wide
sudo make install

# Verify installation
dosbox-x --version

# Clean up source directory (optional)
cd ..
rm -rf dosbox-x
```

**Build Time:** ~5-10 minutes depending on system specs

**Alternative Build Options:**

```bash
# Build with specific options
./build --enable-sdl2

# Build debug version
./build --enable-debug

# Build with Fluidsynth MIDI support
./build --enable-fluidsynth

# See all build options
./build --help
```

**Troubleshooting Build Issues:**

If you encounter missing dependencies:
```bash
# Ubuntu/Debian
sudo apt-get build-dep dosbox

# Install additional SDL2 libraries
sudo apt-get install libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev
```

If build fails, check the DOSBox-X wiki: https://github.com/joncampbell123/dosbox-x/wiki/Building

---

### Step 2: Install Node.js Dependencies

```bash
# Navigate to BinktermPHP directory
cd /path/to/binkterm-php

# Create package.json for bridge server
cat > bridge-server-package.json <<EOF
{
  "name": "binkterm-dosbox-bridge",
  "version": "1.0.0",
  "description": "DOSBox door game bridge server",
  "main": "scripts/door-bridge-server.js",
  "dependencies": {
    "ws": "^8.16.0",
    "iconv-lite": "^0.6.3"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
EOF

# Install Node packages
npm install --prefix ./ ws@^8.16.0 iconv-lite@^0.6.3

# Or install globally for system-wide access
sudo npm install -g ws@^8.16.0 iconv-lite@^0.6.3
```

### Step 3: Install Frontend Dependencies

```bash
# Install xterm.js and addons via npm
cd public_html
mkdir -p vendor/xterm

# Download xterm.js from CDN or install via npm
npm install xterm@^5.3.0 \
    xterm-addon-fit@^0.8.0 \
    xterm-addon-webgl@^0.16.0

# Copy to vendor directory
cp -r node_modules/xterm/css/* vendor/xterm/
cp -r node_modules/xterm/lib/* vendor/xterm/
cp -r node_modules/xterm-addon-fit/lib/* vendor/xterm/
cp -r node_modules/xterm-addon-webgl/lib/* vendor/xterm/

# Alternative: Use CDN links in templates
# <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
# <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
```

### Step 4: Configure DOSBox-X

```bash
# Create DOSBox-X config directory
mkdir -p /etc/dosbox-x

# Create base configuration template
cat > /etc/dosbox-x/base.conf <<EOF
[sdl]
fullscreen=false
output=opengl

[dosbox]
machine=svga_s3
memsize=16

[render]
aspect=true
scaler=normal2x

[cpu]
core=auto
cputype=auto
cycles=10000

[sblaster]
sbtype=none

[serial]
# This will be overridden per session
serial1=disabled
serial2=disabled
serial3=disabled
serial4=disabled

[dos]
xms=true
ems=true
umb=true

[ipx]
ipx=false

[autoexec]
# Session-specific autoexec will be appended
EOF

# Set permissions
sudo chmod 644 /etc/dosbox-x/base.conf
```

### Step 5: Create Door Directories

```bash
# Set BinktermPHP base directory
BINKTERM_BASE="/var/www/binkterm"  # Adjust to your installation path

# Create directory structure
sudo mkdir -p "$BINKTERM_BASE/data/doors"
sudo mkdir -p "$BINKTERM_BASE/data/run/door_sessions"
sudo mkdir -p "$BINKTERM_BASE/data/logs/doors"

# Set ownership to web user
sudo chown -R www-data:www-data "$BINKTERM_BASE/data/doors"
sudo chown -R www-data:www-data "$BINKTERM_BASE/data/run/door_sessions"
sudo chown -R www-data:www-data "$BINKTERM_BASE/data/logs/doors"

# Set permissions
sudo chmod 755 "$BINKTERM_BASE/data/doors"
sudo chmod 750 "$BINKTERM_BASE/data/run/door_sessions"
sudo chmod 750 "$BINKTERM_BASE/data/logs/doors"
```

### Step 6: Database Setup

```bash
# Run database migration
php scripts/upgrade.php

# Or manually apply SQL
psql -U binkterm -d binkterm_db -f database/migrations/v1.10.0_dosbox_doors.sql
```

### Step 7: Configure Supervisor (Production)

```bash
# Create supervisor config for bridge cleanup daemon
sudo cat > /etc/supervisor/conf.d/binkterm-door-cleanup.conf <<EOF
[program:binkterm-door-cleanup]
command=/usr/bin/php /var/www/binkterm/scripts/door_cleanup_daemon.php
directory=/var/www/binkterm
user=www-data
autostart=true
autorestart=true
redirect_stderr=true
stdout_logfile=/var/log/binkterm/door-cleanup.log
EOF

# Reload supervisor
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start binkterm-door-cleanup
```

### Step 8: Configure Nginx (Optional)

If using Nginx as reverse proxy for WebSockets:

```nginx
# /etc/nginx/sites-available/binkterm-doors
upstream dosbox_bridge {
    server 127.0.0.1:15000;
}

server {
    listen 443 ssl;
    server_name bbs.example.com;

    # SSL configuration
    ssl_certificate /etc/ssl/certs/bbs.example.com.crt;
    ssl_certificate_key /etc/ssl/private/bbs.example.com.key;

    # WebSocket proxy for DOSBox bridges
    location /dosbox-ws/ {
        proxy_pass http://dosbox_bridge/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket timeouts
        proxy_connect_timeout 7d;
        proxy_send_timeout 7d;
        proxy_read_timeout 7d;
    }

    # Other BinktermPHP locations...
}
```

### Step 9: Verify Installation

```bash
# Test DOSBox
dosbox -version

# Test Node.js modules
node -e "const ws = require('ws'); console.log('ws:', ws.Server ? 'OK' : 'FAIL')"
node -e "const iconv = require('iconv-lite'); console.log('iconv:', iconv.decode ? 'OK' : 'FAIL')"

# Test PHP extensions
php -m | grep -E '(sockets|pcntl|posix)'

# Check directories
ls -la "$BINKTERM_BASE/data/doors"
ls -la "$BINKTERM_BASE/data/run/door_sessions"
ls -la "$BINKTERM_BASE/data/logs/doors"

# Check database
psql -U binkterm -d binkterm_db -c "SELECT * FROM dosbox_doors LIMIT 1;"
```

### Step 10: Test Basic Bridge

```bash
# Start a test bridge manually
node scripts/door-bridge-server.js 5000 5001 &

# In another terminal, connect DOSBox to test bridge
dosbox -conf - <<EOF
[serial]
serial1=nullmodem server:127.0.0.1 port:5000

[autoexec]
# Simple test - just echo input
echo Testing bridge connection
EOF

# Test WebSocket connection (using wscat if installed)
npm install -g wscat
wscat -c ws://localhost:5001
```

---

## Future Enhancements

### 1. Door Game Marketplace

- User-submitted door games
- Automatic installation
- Rating and review system

### 2. Cloud DOSBox Hosting

- Offload DOSBox to cloud instances
- Scale dynamically based on demand
- Reduce main server load

### 3. Save State Snapshots

- Save DOSBox state mid-game
- Resume from snapshot
- Enable game pausing

### 4. Spectator Mode

- Allow users to watch others play
- Read-only WebSocket connections
- Social streaming features

### 5. Tournament System

- Scheduled competitive events
- Leaderboards and scoring
- Prize integration

---

## Conclusion

The DOSBox door bridge architecture provides a viable path to running classic DOS BBS door games in BinktermPHP's modern web-based environment. While there are technical challenges around process management, resource allocation, and network bridging, all are solvable with standard web development tools and practices.

The key advantages of this approach:
- **Broad compatibility** with hundreds of existing door games
- **Authentic experience** running actual DOS software
- **Low maintenance** compared to porting each door individually
- **Gradual adoption** can run alongside WebDoors

The recommended path forward is to build a proof-of-concept with a simple door game (like LORD or a simple utility), validate the architecture, then expand to a full production implementation integrated with the WebDoors system.

---

## References

- **DOSBox Official Documentation:** https://www.dosbox.com/wiki/
- **Fossil Driver Specification:** http://www.bbsdocumentary.com/software/IBM/DOS/FOSSIL/
- **xterm.js Documentation:** https://xtermjs.org/
- **Classic Door Games Archive:** http://breakintochat.com/wiki/Main_Page
- **BBS Drop File Formats:** http://goldfndr.home.mindspring.com/dropfile/

---

**END OF PROPOSAL**
