# Outbound Packet Organization by Destination - Implementation Proposal

**DRAFT DOCUMENT - Generated by AI - May not have been reviewed for accuracy**

**Status:** DRAFT
**Generated:** 2026-02-02
**Revised:** 2026-02-14
**Version:** 1.3

---

## ⚠️ Disclaimer

This proposal is a **draft** and was **generated by AI**. It may not have been reviewed for accuracy or completeness. All architectural decisions, implementation details, and performance claims should be reviewed and verified by the development team before implementation.

---

## Executive Summary

This proposal outlines a filesystem reorganization strategy to improve the efficiency of outbound packet processing in BinktermPHP's binkp mailer. The current implementation scans all packets in a flat directory structure for every connection, resulting in unnecessary I/O overhead. This proposal adopts the **Binkley Style Outbound (BSO)** directory structure — the standard used by binkd, Husky, MBSE, and other FTN mailers — to organize outbound mail by destination using zone directories, hex-encoded filenames, point subdirectories, and flow files.

### Key Objectives

- Adopt BSO-compatible outbound directory structure (FTS-5005)
- Organize outbound packets into destination-specific locations (uplinks and downlinks)
- Reduce file I/O operations during packet scanning
- Improve polling efficiency and performance
- Support downlink/point node outbound queuing
- Enable future interoperability with binkd and other BSO-aware mailers
- Maintain backward compatibility during migration
- Provide clear admin tools for packet management

### Expected Benefits

- **Performance:** 50-70% reduction in file I/O operations for typical installations (up to ~90% on busy hubs with evenly distributed traffic)
- **Interoperability:** BSO-standard layout enables future use of binkd or other standard mailers alongside BinktermPHP
- **Clarity:** Easy to see which packets are queued for which destination using standard hex naming
- **Debugging:** Simplified troubleshooting — any FTN sysop familiar with BSO can inspect the outbound
- **Scalability:** Performance scales better with packet count and destination count
- **Downlink support:** Packets for point nodes are pre-sorted into `.pnt/` subdirectories, making inbound polling sessions fast
- **Flow files:** Decouple packet creation from file sending — flow files list files to send, enabling future features like file attaches and TIC distribution

---

## Problem Statement

### Current Implementation

When `binkp_poll` connects to an uplink, it performs the following operations:

1. Scans ALL packets in `data/outbound/*.pkt`
2. Opens EACH packet file and reads its header (58 bytes)
3. Parses the destination address from the header
4. Checks if the destination routes through the current uplink
5. Sends only matching packets

**Performance Impact:**
- 100 packets queued across 3 uplinks = 300 file open operations per polling cycle
- Each uplink connection reads headers for packets destined for OTHER uplinks
- Wasted I/O grows linearly with both packet count and uplink count

### Code Location

**File:** `src/Binkp/Protocol/BinkpSession.php`
**Method:** `sendFiles()` (starts at line ~643)

```php
// Current implementation (simplified)
$pktFiles = glob($outboundPath . '/*.pkt');

foreach ($files as $file) {
    if ($this->currentUplink !== null) {
        $destAddr = $this->getPacketDestination($file);  // Opens and reads header
        if (!$this->config->isDestinationForUplink($destAddr, $this->currentUplink)) {
            continue;  // Skip packet - wasted I/O
        }
    }
    $filesToSend[] = $file;
}
```

### Downlink Gap

The current implementation has no concept of outbound queuing for downlinks (nodes that call *in* to us). When a downlink polls in, there is no efficient way to find packets addressed to it. The proposed directory structure solves this for both uplinks and downlinks.

---

## Proposed Solution

### Overview

Adopt the **Binkley Style Outbound (BSO)** directory structure, the FTN standard defined in FTS-5005 and used by binkd, Husky, MBSE, CrashMail, and most modern FTN mailers. BSO organizes outbound mail using zone directories, hex-encoded filenames derived from destination net/node, point subdirectories, and flow files.

**Efficiency Gain:**
- 100 packets across 3 uplinks + 2 downlinks → ~20 packets per destination
- Each connection reads only relevant files from the destination's BSO location
- 50-70% reduction for typical installations; up to ~90% on busy hubs

### BSO Directory Structure

#### Zone Directories

Each FTN zone gets its own outbound directory:
- **Default zone** (zone 1 typically): `outbound/` (no suffix)
- **Other zones**: `outbound.ZZZ/` where ZZZ is the 3-digit lowercase hex zone number

**Examples:**
```
Zone 1  → data/outbound/           (default zone, no suffix)
Zone 2  → data/outbound.002/
Zone 21 → data/outbound.015/
Zone 99 → data/outbound.063/
```

The default zone is configured in `binkp.json` (typically zone 1 for FidoNet).

#### BSO File Naming

Within each zone directory, files for a destination node use the naming convention:

```
NNNNnnnn.ext
```

Where:
- `NNNN` = 4-digit lowercase hex of the destination **net** number
- `nnnn` = 4-digit lowercase hex of the destination **node** number
- `.ext` = file type and flavor indicator

**File Types:**

| Extension | Description |
|-----------|-------------|
| `.out` | Normal mail packet (bundled .pkt) |
| `.cut` | Crash (immediate) mail packet |
| `.dut` | Direct mail packet |
| `.hut` | Hold mail packet |
| `.flo` | Normal flow file (list of files to send) |
| `.clo` | Crash flow file |
| `.dlo` | Direct flow file |
| `.hlo` | Hold flow file |
| `.ilo` | Immediate flow file |

**Flavor precedence:** crash > direct > normal > hold

**Examples:**
```
1:153/149  in zone 1 (default) → data/outbound/00990095.out
                                  data/outbound/00990095.flo
21:1/100   in zone 21           → data/outbound.015/00010064.out
                                  data/outbound.015/00010064.flo
```

#### Point Subdirectories

Points (subnodes) use a `.pnt` subdirectory under their boss node:

```
NNNNnnnn.pnt/0000pppp.ext
```

Where `pppp` = 4-digit lowercase hex of the point number.

**Examples:**
```
1:123/456.1  → data/outbound/007b01c8.pnt/00000001.out
                data/outbound/007b01c8.pnt/00000001.flo
1:123/456.5  → data/outbound/007b01c8.pnt/00000005.out
99:22/44.3   → data/outbound.063/00160002c.pnt/00000003.out
```

#### Flow Files

Flow files (`.flo`, `.clo`, etc.) are text files listing paths of files to send to the destination. Each line contains an optional prefix followed by a file path:

| Prefix | Meaning |
|--------|---------|
| `^`    | Delete file after successful send |
| `#`    | Truncate file to zero bytes after send |
| (none) | Leave file as-is after send (retain) |

**Example `.flo` file contents:**
```
^/path/to/data/outbound/temp/echomail_bundle_1234.pkt
^/path/to/data/outbound/temp/tic_file.tic
^/path/to/data/outbound/temp/game.zip
```

Most entries will use `^` (delete after send) for outbound packets and TIC files. The flow file itself is deleted when all entries have been sent and the file is empty.

#### Proposed Directory Layout

```
data/outbound/                          # Default zone (zone 1)
├── 00990095.out                        # Bundled packet for 1:153/149
├── 00990095.flo                        # Flow file for 1:153/149
├── 007b01c8.pnt/                       # Point directory for 1:123/456.*
│   ├── 00000001.out                    # Packet for point 1:123/456.1
│   └── 00000001.flo                    # Flow file for point 1:123/456.1
├── temp/                               # Temporary storage for referenced files
│   ├── echomail_a1b2c3d4.pkt          # Individual .pkt referenced by .flo
│   └── somefile.tic                    # TIC file referenced by .flo
├── unroutable/                         # Fallback for packets with no route
│   └── deadletter.pkt
└── (legacy *.pkt files during migration)
data/outbound.015/                      # Zone 21
├── 00010064.out                        # Packet for 21:1/100
└── 00010064.flo                        # Flow file for 21:1/100
```

**Note on `temp/` directory:** Flow files reference actual file paths. Individual `.pkt` and `.tic` files are stored in a `temp/` subdirectory (or the zone directory itself) and referenced by flow file entries. When the file is successfully sent and the flow entry uses `^`, the referenced file is deleted. The flow file itself is deleted when empty.

**Note on uplinks vs downlinks:** BSO does not distinguish between uplinks and downlinks at the directory level. A directory entry is created by converting the **session destination address** to BSO format — for uplinks this is the uplink's address, for downlinks this is the point node's address. Since FTN addresses are unique, there is no collision risk.

---

## Implementation Plan

### Phase 1: Add BSO Helper Utility

**File:** `src/BinkpHelper.php` (new file)

Create a new helper class with static methods for BSO address conversion, path resolution, flow file management, and outbound scanning:

```php
<?php

namespace BinktermPHP;

/**
 * Helper utilities for Binkp protocol operations.
 *
 * Implements Binkley Style Outbound (BSO) directory conventions per FTS-5005.
 * BSO structure: outbound[.ZZZ]/NNNNnnnn.ext with .pnt/ subdirs for points.
 */
class BinkpHelper
{
    /** @var int Default zone number (typically 1 for FidoNet) */
    private static int $defaultZone = 1;

    /**
     * Set the default zone number.
     *
     * The default zone uses the base outbound directory name without a
     * hex suffix. All other zones use outbound.ZZZ/ format.
     *
     * @param int $zone Default zone number
     */
    public static function setDefaultZone(int $zone): void
    {
        self::$defaultZone = $zone;
    }

    /**
     * Parse a FidoNet address into its components.
     *
     * @param string $address Format: "Zone:Net/Node.Point" or "Zone:Net/Node"
     * @return array{zone: int, net: int, node: int, point: int}
     * @throws \InvalidArgumentException If address format is invalid
     */
    public static function parseAddress(string $address): array
    {
        if (!preg_match('/^(\d+):(\d+)\/(\d+)(?:\.(\d+))?$/', $address, $m)) {
            throw new \InvalidArgumentException("Invalid FTN address: $address");
        }
        return [
            'zone'  => (int)$m[1],
            'net'   => (int)$m[2],
            'node'  => (int)$m[3],
            'point' => (int)($m[4] ?? 0),
        ];
    }

    /**
     * Get the BSO zone directory path for a given zone.
     *
     * Default zone uses the base outbound path (no suffix).
     * Other zones use outbound.ZZZ/ where ZZZ is 3-digit lowercase hex.
     *
     * @param int $zone Zone number
     * @param string $outboundBase Base outbound directory path (e.g., "data/outbound")
     * @return string Zone directory path
     */
    public static function getZoneDir(int $zone, string $outboundBase): string
    {
        if ($zone === self::$defaultZone) {
            return $outboundBase;
        }
        $hexZone = str_pad(dechex($zone), 3, '0', STR_PAD_LEFT);
        return $outboundBase . '.' . $hexZone;
    }

    /**
     * Get the BSO base filename (NNNNnnnn) for a net/node pair.
     *
     * @param int $net Net number
     * @param int $node Node number
     * @return string 8-character hex string (e.g., "00990095")
     */
    public static function getNodeBase(int $net, int $node): string
    {
        $hexNet = str_pad(dechex($net), 4, '0', STR_PAD_LEFT);
        $hexNode = str_pad(dechex($node), 4, '0', STR_PAD_LEFT);
        return $hexNet . $hexNode;
    }

    /**
     * Get the BSO outbound path for a given FTN address.
     *
     * Returns the directory where BSO files for this address should be stored.
     * For boss nodes (point=0), this is the zone directory itself.
     * For points (point>0), this is the NNNNnnnn.pnt/ subdirectory.
     *
     * @param string $address FTN address (e.g., "1:153/149" or "1:123/456.1")
     * @param string $outboundBase Base outbound directory path
     * @return string Directory path where BSO files for this address reside
     */
    public static function getBsoDirectory(string $address, string $outboundBase): string
    {
        $addr = self::parseAddress($address);
        $zoneDir = self::getZoneDir($addr['zone'], $outboundBase);
        $nodeBase = self::getNodeBase($addr['net'], $addr['node']);

        if ($addr['point'] > 0) {
            return $zoneDir . '/' . $nodeBase . '.pnt';
        }
        return $zoneDir;
    }

    /**
     * Get the BSO file basename for a given FTN address (without extension).
     *
     * For boss nodes: NNNNnnnn
     * For points: 0000pppp (inside the .pnt directory)
     *
     * @param string $address FTN address
     * @return string BSO file basename (e.g., "00990095" or "00000001")
     */
    public static function getBsoFileBase(string $address): string
    {
        $addr = self::parseAddress($address);
        if ($addr['point'] > 0) {
            return '0000' . str_pad(dechex($addr['point']), 4, '0', STR_PAD_LEFT);
        }
        return self::getNodeBase($addr['net'], $addr['node']);
    }

    /**
     * Convert a BSO path back to a FidoNet address.
     *
     * Parses zone from directory name, net/node from filename, point from
     * .pnt directory context.
     *
     * @param string $filePath Full path to a BSO file
     * @param string $outboundBase Base outbound directory path
     * @return string FidoNet address (e.g., "1:153/149" or "1:123/456.1")
     * @throws \InvalidArgumentException If path does not match BSO format
     */
    public static function bsoPathToAddress(string $filePath, string $outboundBase): string
    {
        $dir = dirname($filePath);
        $basename = pathinfo($filePath, PATHINFO_FILENAME);

        // Determine zone from directory
        $parentDir = basename($dir);
        $grandparentDir = basename(dirname($dir));
        $zone = self::$defaultZone;
        $point = 0;

        // Check if file is inside a .pnt directory
        if (str_ends_with($parentDir, '.pnt')) {
            // Point file: dir is NNNNnnnn.pnt, file is 0000pppp.ext
            $nodeBase = substr($parentDir, 0, -4); // strip .pnt
            $point = hexdec(substr($basename, 4, 4));

            // Zone from grandparent directory
            $zoneDir = basename(dirname($dir));
            if (preg_match('/^outbound\.([0-9a-f]{3})$/i', $zoneDir, $zm)) {
                $zone = hexdec($zm[1]);
            }
        } else {
            // Boss node file: dir is zone dir, file is NNNNnnnn.ext
            $nodeBase = $basename;
            if (preg_match('/^outbound\.([0-9a-f]{3})$/i', $parentDir, $zm)) {
                $zone = hexdec($zm[1]);
            }
        }

        if (!preg_match('/^[0-9a-f]{8}$/i', $nodeBase)) {
            throw new \InvalidArgumentException("Invalid BSO filename: $nodeBase");
        }

        $net = hexdec(substr($nodeBase, 0, 4));
        $node = hexdec(substr($nodeBase, 4, 4));

        $address = "$zone:$net/$node";
        if ($point > 0) {
            $address .= ".$point";
        }
        return $address;
    }

    /**
     * Get the full outbound path for a destination, resolving routing.
     *
     * Resolves the destination to either an uplink (via routing table) or
     * treats it as a direct destination (e.g. a downlink/point node).
     * Returns the BSO directory and file base for that session destination.
     *
     * For uplink-routed destinations, the BSO location is keyed to the
     * uplink's address. For downlink/point destinations, it is keyed to
     * the destination address itself.
     *
     * @param string $destAddr Destination FTN address (e.g., "1:123/456.1")
     * @param string $outboundBase Base outbound directory path
     * @param Config\BinkpConfig|null $config Optional config for uplink route lookup
     * @return array{dir: string, fileBase: string, routed: bool, routeAddr: string}
     *         dir = directory path, fileBase = BSO filename without extension,
     *         routed = true if routed through uplink, routeAddr = actual session address
     */
    public static function getOutboundPathForAddress(
        string $destAddr,
        string $outboundBase,
        ?Config\BinkpConfig $config = null
    ): array {
        $config = $config ?: Config\BinkpConfig::getInstance();

        // Try to route through an uplink first
        $uplink = $config->getUplinkForDestination($destAddr);

        if ($uplink) {
            $routeAddr = $uplink['address'];
        } elseif ($config->isDownlinkAddress($destAddr)) {
            $routeAddr = $destAddr;
        } else {
            // No route and not a known downlink — unroutable
            $path = $outboundBase . '/unroutable';
            if (!is_dir($path)) {
                mkdir($path, 0755, true);
            }
            return [
                'dir'       => $path,
                'fileBase'  => substr(uniqid(), -8),
                'routed'    => false,
                'routeAddr' => '',
            ];
        }

        $dir = self::getBsoDirectory($routeAddr, $outboundBase);
        if (!is_dir($dir)) {
            mkdir($dir, 0755, true);
        }

        return [
            'dir'       => $dir,
            'fileBase'  => self::getBsoFileBase($routeAddr),
            'routed'    => true,
            'routeAddr' => $routeAddr,
        ];
    }

    /**
     * Append a file path entry to a flow file.
     *
     * Creates the flow file if it does not exist. Appends the file path
     * with the specified action prefix.
     *
     * @param string $floPath Full path to the .flo file
     * @param string $filePath Absolute path to the file to send
     * @param string $prefix Action prefix: "^" (delete), "#" (truncate), "" (retain)
     */
    public static function appendToFlowFile(
        string $floPath,
        string $filePath,
        string $prefix = '^'
    ): void {
        // Ensure directory exists
        $dir = dirname($floPath);
        if (!is_dir($dir)) {
            mkdir($dir, 0755, true);
        }

        file_put_contents($floPath, $prefix . $filePath . "\n", FILE_APPEND | LOCK_EX);
    }

    /**
     * Read and parse a flow file, returning file entries.
     *
     * @param string $floPath Full path to the .flo file
     * @return array Array of ['prefix' => string, 'path' => string] entries
     */
    public static function readFlowFile(string $floPath): array
    {
        if (!file_exists($floPath)) {
            return [];
        }

        $entries = [];
        $lines = file($floPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        foreach ($lines as $line) {
            $line = trim($line);
            if ($line === '') continue;

            $prefix = '';
            if (in_array($line[0], ['^', '#', '@'])) {
                $prefix = $line[0];
                $line = substr($line, 1);
            }
            $entries[] = ['prefix' => $prefix, 'path' => $line];
        }
        return $entries;
    }

    /**
     * Remove a sent file entry from a flow file.
     *
     * Removes the line matching the file path. If the flow file becomes
     * empty, deletes the flow file itself.
     *
     * @param string $floPath Full path to the .flo file
     * @param string $sentFilePath Path of the file that was sent
     */
    public static function removeFlowFileEntry(string $floPath, string $sentFilePath): void
    {
        if (!file_exists($floPath)) return;

        $lines = file($floPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        $remaining = [];
        foreach ($lines as $line) {
            $path = ltrim(trim($line), '^#@');
            if ($path !== $sentFilePath) {
                $remaining[] = $line;
            }
        }

        if (empty($remaining)) {
            @unlink($floPath);
        } else {
            file_put_contents($floPath, implode("\n", $remaining) . "\n", LOCK_EX);
        }
    }

    /**
     * Scan outbound for all files queued for a specific destination.
     *
     * Reads the BSO files (.out/.cut/.dut/.hut packets and .flo/.clo/.dlo/.hlo
     * flow file entries) for the given address and returns all file paths.
     *
     * @param string $address FTN address of the destination
     * @param string $outboundBase Base outbound directory path
     * @return array Array of ['path' => string, 'deleteAfter' => bool] entries
     */
    public static function getFilesForDestination(
        string $address,
        string $outboundBase
    ): array {
        $dir = self::getBsoDirectory($address, $outboundBase);
        $base = self::getBsoFileBase($address);
        $files = [];

        if (!is_dir($dir)) {
            return $files;
        }

        // Check for direct packet files (.out, .cut, .dut, .hut)
        foreach (['out', 'cut', 'dut', 'hut'] as $ext) {
            $pktPath = $dir . '/' . $base . '.' . $ext;
            if (file_exists($pktPath)) {
                $files[] = ['path' => $pktPath, 'deleteAfter' => true];
            }
        }

        // Check for flow files (.flo, .clo, .dlo, .hlo, .ilo)
        foreach (['flo', 'clo', 'dlo', 'hlo', 'ilo'] as $ext) {
            $floPath = $dir . '/' . $base . '.' . $ext;
            $entries = self::readFlowFile($floPath);
            foreach ($entries as $entry) {
                if (file_exists($entry['path'])) {
                    $files[] = [
                        'path'        => $entry['path'],
                        'deleteAfter' => ($entry['prefix'] === '^'),
                        'truncate'    => ($entry['prefix'] === '#'),
                        'floPath'     => $floPath,
                    ];
                }
            }
        }

        return $files;
    }

    /**
     * Scan the entire outbound tree for any queued mail.
     *
     * Returns true if there are any BSO files (.out/.cut/.dut/.hut or
     * .flo/.clo/.dlo/.hlo/.ilo) in any zone directory. Used for guard
     * checks (e.g., "is there any outbound mail at all?").
     *
     * Also checks the flat directory for legacy .pkt files during migration.
     *
     * @param string $outboundBase Base outbound directory path
     * @return bool True if any outbound mail exists
     */
    public static function hasOutboundMail(string $outboundBase): bool
    {
        // Check all zone directories
        $zoneDirs = [realpath($outboundBase)];
        $parentDir = dirname($outboundBase);
        $baseName = basename($outboundBase);
        $extraZones = glob($parentDir . '/' . $baseName . '.[0-9a-f][0-9a-f][0-9a-f]') ?: [];
        foreach ($extraZones as $zd) {
            $zoneDirs[] = $zd;
        }

        $bsoExts = ['out', 'cut', 'dut', 'hut', 'flo', 'clo', 'dlo', 'hlo', 'ilo'];
        foreach ($zoneDirs as $zoneDir) {
            if (!is_dir($zoneDir)) continue;
            foreach ($bsoExts as $ext) {
                // Check zone dir directly (boss node files)
                if (!empty(glob($zoneDir . '/*.' . $ext))) return true;
                // Check .pnt subdirectories (point files)
                $pntDirs = glob($zoneDir . '/*.pnt', GLOB_ONLYDIR) ?: [];
                foreach ($pntDirs as $pntDir) {
                    if (!empty(glob($pntDir . '/*.' . $ext))) return true;
                }
            }
        }

        // Legacy flat packets (migration support)
        if (!empty(glob($outboundBase . '/*.pkt'))) return true;

        return false;
    }

    /**
     * Scan all outbound for packet files (legacy compatibility scanner).
     *
     * Returns .pkt files from legacy flat directory, BSO .out/.cut/.dut/.hut
     * files, and files referenced by flow files. Used by callers that need
     * a complete list of all queued outbound files.
     *
     * @param string $outboundBase Base outbound directory path
     * @return array Full paths to all outbound files found
     */
    public static function scanAllOutbound(string $outboundBase): array
    {
        $files = [];

        // Legacy flat packets
        $files = array_merge($files, glob($outboundBase . '/*.pkt') ?: []);

        // BSO files across all zones
        $zoneDirs = [realpath($outboundBase)];
        $parentDir = dirname($outboundBase);
        $baseName = basename($outboundBase);
        $extraZones = glob($parentDir . '/' . $baseName . '.[0-9a-f][0-9a-f][0-9a-f]') ?: [];
        foreach ($extraZones as $zd) {
            $zoneDirs[] = $zd;
        }

        foreach ($zoneDirs as $zoneDir) {
            if (!is_dir($zoneDir)) continue;
            // Direct packet files in zone dir
            foreach (['out', 'cut', 'dut', 'hut'] as $ext) {
                $files = array_merge($files, glob($zoneDir . '/*.' . $ext) ?: []);
            }
            // Point subdirectories
            $pntDirs = glob($zoneDir . '/*.pnt', GLOB_ONLYDIR) ?: [];
            foreach ($pntDirs as $pntDir) {
                foreach (['out', 'cut', 'dut', 'hut'] as $ext) {
                    $files = array_merge($files, glob($pntDir . '/*.' . $ext) ?: []);
                }
            }
            // Flow file referenced files
            foreach (['flo', 'clo', 'dlo', 'hlo', 'ilo'] as $ext) {
                $floFiles = array_merge(
                    glob($zoneDir . '/*.' . $ext) ?: [],
                );
                foreach (glob($zoneDir . '/*.pnt', GLOB_ONLYDIR) ?: [] as $pntDir) {
                    $floFiles = array_merge($floFiles, glob($pntDir . '/*.' . $ext) ?: []);
                }
                foreach ($floFiles as $floFile) {
                    foreach (self::readFlowFile($floFile) as $entry) {
                        if (file_exists($entry['path'])) {
                            $files[] = $entry['path'];
                        }
                    }
                }
            }
        }

        return array_unique($files);
    }
}
```

**Key design decisions:**

1. **`getOutboundPathForAddress()`** centralises the routing-to-directory logic so that both `BinkdProcessor::createOutboundPacket()` and future downlink broadcasting code share the same BSO path resolution. The method handles three cases:
   - **Uplink-routed** — destination matches an uplink's network patterns → BSO location keyed to uplink address
   - **Downlink** — destination is a registered downlink/point node → BSO location keyed to the point's own address
   - **Unroutable** — no route and not a downlink → `unroutable/` fallback

2. **Flow file management** — `appendToFlowFile()`, `readFlowFile()`, and `removeFlowFileEntry()` provide atomic flow file operations with file locking.

3. **`getFilesForDestination()`** is the primary method for BinkpSession to find all files to send to a specific destination during a session. It reads both direct BSO packets (.out) and flow file references (.flo).

4. **`hasOutboundMail()`** replaces the flat `glob('*.pkt')` guard checks used by Scheduler and BinkpClient.

5. **`scanAllOutbound()`** provides a complete list of all queued files for admin UI display and statistics.

### Phase 2: Update Packet Creation

**File:** `src/BinkdProcessor.php`
**Method:** `createOutboundPacket()`

**Changes Required:**

1. Use `BinkpHelper::getOutboundPathForAddress()` to determine the BSO location
2. Write the packet to a temp file, then reference it from a flow file
3. Auto-create zone directories and .pnt subdirectories as needed
4. Log a warning for unroutable packets

**Important distinction:** The `$destAddr` parameter represents the packet's header destination (the final recipient). For uplink routing, this address is matched against uplink network patterns to determine *which uplink* carries the packet. The BSO location is keyed to the **uplink's address**, not the final destination. For downlinks, the BSO location is keyed to the **destination address itself** since we deliver directly. This distinction is handled by `getOutboundPathForAddress()`.

**Implementation:**

```php
public function createOutboundPacket($messages, $destAddr, $outputPath = null)
{
    // If outputPath explicitly provided, use it (backward compatibility)
    if ($outputPath !== null) {
        $filename = $outputPath;
    } else {
        // Use centralized BSO routing
        $bso = BinkpHelper::getOutboundPathForAddress($destAddr, $this->outboundPath);

        if (!$bso['routed']) {
            $this->log("[BINKD] WARNING: No route for $destAddr - packet queued in unroutable/");
            $filename = $bso['dir'] . '/' . substr(uniqid(), -8) . '.pkt';
        } else {
            // Write packet to temp directory, then add to flow file
            $tempDir = $this->outboundPath . '/temp';
            if (!is_dir($tempDir)) {
                mkdir($tempDir, 0755, true);
            }
            $filename = $tempDir . '/' . substr(uniqid(), -8) . '.pkt';
        }
    }

    $packetName = basename($filename);
    $handle = fopen($filename, 'wb');

    // ... write packet data (unchanged) ...

    fclose($handle);

    // If BSO-routed, add to flow file
    if ($outputPath === null && isset($bso) && $bso['routed']) {
        $floPath = $bso['dir'] . '/' . $bso['fileBase'] . '.flo';
        BinkpHelper::appendToFlowFile($floPath, realpath($filename), '^');
    }

    // Rest of function remains unchanged...
}
```

**BSO flow:** Instead of placing `.pkt` files directly into per-destination directories, we:
1. Write the `.pkt` to `data/outbound/temp/` (a staging area)
2. Append the path to the destination's `.flo` flow file with `^` prefix (delete after send)
3. During a session, `getFilesForDestination()` reads the flow file and returns the referenced paths

**Backward Compatibility:**
- Explicit `$outputPath` parameter still honored (used by tests and special cases)
- No breaking changes to method signature

### Phase 3: Update All Outbound Glob Callers

Multiple files beyond `BinkpSession::sendFiles()` scan the flat outbound directory with `glob($outboundPath . '/*.pkt')`. All must switch to BSO-aware scanning.

| File | Method | Current pattern | BSO replacement |
|---|---|---|---|
| `OutboundQueue.php` | `processOutbound()` | `glob('*.pkt')` | `BinkpHelper::hasOutboundMail()` |
| `OutboundQueue.php` | `getOutboundFiles()` | `glob('*.pkt')` | `BinkpHelper::scanAllOutbound()` |
| `OutboundQueue.php` | `getStats()` | `glob('*.pkt')` | `BinkpHelper::scanAllOutbound()` |
| `BinkpClient.php` | `pollAllUplinks()` | `glob('*.pkt')` | `BinkpHelper::hasOutboundMail()` |
| `Scheduler.php` | `pollIfOutbound()` | `glob('*.pkt')` | `BinkpHelper::hasOutboundMail()` |

**Guard checks** (processOutbound, pollAllUplinks, pollIfOutbound) only need to know if *any* outbound mail exists — use `hasOutboundMail()` which returns a boolean and short-circuits on the first match.

**Admin display** (getOutboundFiles, getStats) need the full file list — use `scanAllOutbound()`.

**Note:** `Scheduler::processInboundIfNeeded()` and `InboundQueue` scan the **inbound** directory, which is not being restructured — no changes needed there.

### Phase 4: Update BinkpSession File Sending

**File:** `src/Binkp/Protocol/BinkpSession.php`
**Method:** `sendFiles()` (starts at line ~643)

**Changes Required:**

1. Determine the session destination address:
   - **Uplink sessions (originator):** use `$this->currentUplink['address']`
   - **Downlink sessions (answerer):** use `$this->remoteAddress` (the downlink's own address)
2. Use `BinkpHelper::getFilesForDestination($address, $outboundPath)` to get all files queued for this destination
3. After each file is sent successfully, handle cleanup based on file metadata:
   - BSO `.out` files: delete after send
   - Flow file entries with `^` prefix: delete the referenced file, then remove the flow entry
   - Flow file entries with `#` prefix: truncate the referenced file, then remove the flow entry
4. Fall back to legacy flat scan for old `.pkt` files during migration

**Implementation approach:**

```php
// In sendFiles():
$sessionAddr = $this->isDownlink
    ? $this->remoteAddress
    : $this->currentUplink['address'];

// Get BSO files for this destination
$bsoFiles = BinkpHelper::getFilesForDestination($sessionAddr, $outboundPath);

foreach ($bsoFiles as $fileInfo) {
    // Send file...
    // On success:
    if ($fileInfo['deleteAfter'] ?? false) {
        @unlink($fileInfo['path']);
    } elseif ($fileInfo['truncate'] ?? false) {
        file_put_contents($fileInfo['path'], '');
    }
    if (isset($fileInfo['floPath'])) {
        BinkpHelper::removeFlowFileEntry($fileInfo['floPath'], $fileInfo['path']);
    }
}

// Also check legacy flat directory during migration period
$legacyFiles = glob($outboundPath . '/*.pkt') ?: [];
foreach ($legacyFiles as $file) {
    $destAddr = $this->getPacketDestination($file);
    if ($this->currentUplink && !$this->config->isDestinationForUplink($destAddr, $this->currentUplink)) {
        continue;
    }
    // Send and delete...
}
```

**Answerer-mode note:** Currently `sendFiles()` is only called in the originator branch of `processSession()`. For downlink support, `sendFiles()` must also be called in the answerer branch when the remote is a downlink. This is a separate change tracked in the downlink/point node support proposal, but the BSO directory structure defined here supports it.

### Phase 5: Update TIC File Handling

TIC files (file transfer metadata) come in pairs: a `.tic` metadata file and its associated data file.

**BSO approach:** In BSO, TIC files and their associated data files are handled through flow files rather than being placed directly in BSO directories:

1. Both the `.tic` file and its data file are written to `data/outbound/temp/`
2. Both paths are appended to the destination's `.flo` flow file with `^` (delete after send)
3. During a session, `getFilesForDestination()` returns them along with all other queued files
4. After successful send, both files are deleted from temp and their flow entries removed

**Key considerations:**
- The `To` field inside the `.tic` file determines routing (which uplink/downlink flow file to use)
- Both the `.tic` and data file must be added to the **same** flow file atomically
- During migration, the migration script must parse the `To` field from each flat `.tic` file and add both files to the correct flow file
- Legacy flat TIC files are handled during migration and by the flat-directory fallback in `sendFiles()`

### Phase 6: Migration Script and Database Migration

**Files:**
- `scripts/migrate_outbound_structure.php` (new file) — standalone script that can be re-run manually at any time
- `database/migrations/vX.Y.Z_migrate_outbound_structure.php` (new file) — PHP migration that calls the script, executed automatically by `upgrade.php` during `setup.php`

The migration file delegates to the standalone script so that:
1. `setup.php` → `upgrade.php` runs it automatically during upgrade
2. Admins can re-run it manually if needed (e.g. after adding new uplinks/downlinks, or if packets ended up in `unroutable/`)

**Migration file:**
```php
<?php
/**
 * Migration: vX.Y.Z - Migrate outbound packets to BSO directory structure
 */
return function($db) {
    $script = __DIR__ . '/../../scripts/migrate_outbound_structure.php';
    echo "Running outbound BSO migration...\n";
    require $script;
    return true;
};
```

**Race condition warning:** If `binkp_poll` or `binkp_server` runs while migration is in progress, a packet could be missed or double-sent. When run via `setup.php`, the mailer should already be stopped. When run manually, the script acquires an exclusive lock and warns the operator.

**Migration script — converts flat .pkt/.tic files to BSO flow file entries:**

```php
#!/usr/bin/env php
<?php

// Support being called both standalone and from upgrade.php
if (!class_exists('BinktermPHP\Binkp\Config\BinkpConfig')) {
    require __DIR__ . '/../vendor/autoload.php';
    require_once __DIR__ . '/../src/functions.php';
}

use BinktermPHP\Binkp\Config\BinkpConfig;
use BinktermPHP\BinkpHelper;

$config = BinkpConfig::getInstance();
$outboundPath = $config->getOutboundPath();

// Set default zone from config
$defaultZone = $config->getDefaultZone() ?? 1;
BinkpHelper::setDefaultZone($defaultZone);

echo "=== Outbound BSO Migration ===\n\n";
echo "Outbound path: $outboundPath\n";
echo "Default zone: $defaultZone\n\n";

// Acquire exclusive lock to prevent concurrent mailer access
$lockFile = $outboundPath . '/.migration.lock';
$lockHandle = fopen($lockFile, 'w');
if (!flock($lockHandle, LOCK_EX | LOCK_NB)) {
    echo "ERROR: Cannot acquire lock - another migration or mailer may be running.\n";
    echo "Stop binkp_server and binkp_poll before running migration.\n";
    return false;
}

// Only prompt interactively when run standalone (not from upgrade.php)
$isStandalone = (php_sapi_name() === 'cli' && realpath($_SERVER['SCRIPT_FILENAME'] ?? '') === realpath(__FILE__));
if ($isStandalone) {
    echo "WARNING: Ensure binkp_server and binkp_poll are stopped before proceeding.\n";
    echo "Press Enter to continue or Ctrl+C to abort...\n";
    fgets(STDIN);
}

// Ensure temp directory exists
$tempDir = $outboundPath . '/temp';
if (!is_dir($tempDir)) {
    mkdir($tempDir, 0755, true);
}

// Scan for flat packets and TIC files
$flatPackets = glob($outboundPath . '/*.pkt') ?: [];
$flatTics = glob($outboundPath . '/*.tic') ?: [];
echo "Found " . count($flatPackets) . " packets and " . count($flatTics) . " TIC files in flat directory\n\n";

if (empty($flatPackets) && empty($flatTics)) {
    echo "No files to migrate!\n";
    flock($lockHandle, LOCK_UN);
    fclose($lockHandle);
    @unlink($lockFile);
    return true;
}

$moved = 0;
$failed = 0;
$unroutable = 0;

foreach ($flatPackets as $packet) {
    $basename = basename($packet);
    echo "Processing: $basename ... ";

    // Read packet header to get destination
    $handle = fopen($packet, 'rb');
    if (!$handle) {
        echo "FAILED (cannot open)\n";
        $failed++;
        continue;
    }

    $header = fread($handle, 58);
    fclose($handle);

    if (strlen($header) < 58) {
        echo "FAILED (invalid header)\n";
        $failed++;
        continue;
    }

    // Parse destination address from packet header (including point)
    $data = unpack('vorigNode/vdestNode', substr($header, 0, 4));
    $netData = unpack('vorigNet/vdestNet', substr($header, 20, 4));

    $destZone = $defaultZone;
    if (strlen($header) >= 38) {
        $zoneData = unpack('vdestZone', substr($header, 36, 2));
        $destZone = $zoneData['destZone'] ?? $defaultZone;
    }

    // Read destPoint from FSC-39 (Type-2e) offset 30-31
    $destPoint = 0;
    if (strlen($header) >= 32) {
        $pointData = unpack('vdestPoint', substr($header, 30, 2));
        $destPoint = $pointData['destPoint'] ?? 0;
    }

    $destAddr = $destZone . ':' . $netData['destNet'] . '/' . $data['destNode'];
    if ($destPoint > 0) {
        $destAddr .= '.' . $destPoint;
    }

    // Use centralized BSO routing
    $bso = BinkpHelper::getOutboundPathForAddress($destAddr, $outboundPath, $config);

    if (!$bso['routed']) {
        // Unroutable — move to unroutable/ directory as-is
        $targetPath = $bso['dir'] . '/' . $basename;
        if (rename($packet, $targetPath)) {
            echo "UNROUTABLE (moved to unroutable/)\n";
            $unroutable++;
        } else {
            echo "FAILED (cannot move)\n";
            $failed++;
        }
        continue;
    }

    // Move packet to temp directory
    $tempPath = $tempDir . '/' . $basename;
    if (!rename($packet, $tempPath)) {
        echo "FAILED (cannot move to temp)\n";
        $failed++;
        continue;
    }

    // Add to flow file
    $floPath = $bso['dir'] . '/' . $bso['fileBase'] . '.flo';
    BinkpHelper::appendToFlowFile($floPath, realpath($tempPath), '^');

    echo "OK → " . $bso['routeAddr'] . " (.flo)\n";
    $moved++;
}

// Migrate TIC pairs (tic + data file → flow file entries)
foreach ($flatTics as $ticFile) {
    $ticBasename = basename($ticFile);
    echo "Processing TIC: $ticBasename ... ";

    $ticContent = @file_get_contents($ticFile);
    if ($ticContent === false) {
        echo "FAILED (cannot read)\n";
        $failed++;
        continue;
    }

    // Parse To and File fields
    $destAddr = null;
    $dataFilename = null;
    foreach (explode("\n", $ticContent) as $line) {
        $line = trim($line);
        if (preg_match('/^To\s+(.+)$/i', $line, $m)) $destAddr = trim($m[1]);
        if (preg_match('/^File\s+(.+)$/i', $line, $m)) $dataFilename = trim($m[1]);
    }

    if (!$destAddr) {
        echo "FAILED (no To field)\n";
        $failed++;
        continue;
    }

    $bso = BinkpHelper::getOutboundPathForAddress($destAddr, $outboundPath, $config);

    if (!$bso['routed']) {
        // Move both files to unroutable/
        if ($dataFilename) {
            $dataPath = dirname($ticFile) . '/' . $dataFilename;
            if (file_exists($dataPath)) {
                rename($dataPath, $bso['dir'] . '/' . $dataFilename);
            }
        }
        rename($ticFile, $bso['dir'] . '/' . $ticBasename);
        echo "UNROUTABLE\n";
        $unroutable++;
        continue;
    }

    // Move data file to temp first (if it exists), then TIC file
    $floPath = $bso['dir'] . '/' . $bso['fileBase'] . '.flo';
    $dataOk = true;

    if ($dataFilename) {
        $dataPath = dirname($ticFile) . '/' . $dataFilename;
        if (file_exists($dataPath)) {
            $tempDataPath = $tempDir . '/' . $dataFilename;
            if (rename($dataPath, $tempDataPath)) {
                BinkpHelper::appendToFlowFile($floPath, realpath($tempDataPath), '^');
            } else {
                echo "FAILED (cannot move data file)\n";
                $failed++;
                $dataOk = false;
            }
        }
    }

    if ($dataOk) {
        $tempTicPath = $tempDir . '/' . $ticBasename;
        if (rename($ticFile, $tempTicPath)) {
            BinkpHelper::appendToFlowFile($floPath, realpath($tempTicPath), '^');
            echo "OK → " . $bso['routeAddr'] . " (.flo)\n";
            $moved++;
        } else {
            echo "FAILED (cannot move TIC)\n";
            $failed++;
        }
    }
}

// Release lock
flock($lockHandle, LOCK_UN);
fclose($lockHandle);
@unlink($lockFile);

echo "\n=== Migration Complete ===\n";
echo "Successfully migrated: $moved\n";
echo "Unroutable: $unroutable\n";
echo "Failed: $failed\n";

return $failed === 0;
```

---

## Edge Cases and Error Handling

### 1. No Route Found
**Scenario:** Packet created for destination with no configured uplink and destination is not a registered downlink

**Solution:**
- Create packet in `data/outbound/unroutable/` subdirectory (not BSO-formatted)
- Log warning message with destination address
- Admin can review unroutable/ directory periodically
- Re-running migration script after adding a route will pick these up

### 2. Uplink Configuration Changes
**Scenario:** Uplink address changes after packets are queued

**Solution:**
- Old flow files and BSO entries remain under the old address's hex name
- Re-run migration script to reorganize — it scans temp/ for orphaned files and re-routes them
- Document that changing uplink addresses requires migration

### 3. Downlink Added After Packets Queued
**Scenario:** Echomail packets for a point address were created before that point was registered as a downlink, so they landed in `unroutable/`

**Solution:**
- Re-run migration script — it will now find a downlink match and create proper flow file entries
- Alternatively, the admin can manually move files from `unroutable/` to `temp/` and re-run migration

### 4. Multiple Uplinks for Same Destination
**Scenario:** Broadcast packets or load balancing

**Current Behavior:**
- `getUplinkForDestination()` returns first matching uplink
- Flow file entry added to first uplink's BSO location only

**Limitation Accepted:** First match wins (consistent with current routing logic)

### 5. Packet Destination Parsing Failures
**Solution:**
- Leave packet in flat directory (not moved during migration)
- Log error with packet filename
- Admin can manually inspect and fix/delete

### 6. Filesystem Permission Issues
**Solution:**
- Log error and continue processing other packets
- Migration script exits with error code if any failures
- Admin must fix permissions and re-run

### 7. Concurrent Mailer Access During Migration
**Scenario:** `binkp_poll` or `binkp_server` runs while migration script is moving files

**Risk:** Packet could be missed (moved after scan, before send) or double-sent (sent from flat dir, then sent again from flow file)

**Solution:**
- Migration script acquires an exclusive file lock
- Script warns operator to stop mailer processes before proceeding
- Uses `rename()` which is atomic on the same filesystem

### 8. Downlink Deleted While Packets Queued
**Scenario:** Admin deletes a downlink that still has packets queued (flow file entries + temp files)

**Solution:**
- Deleting a downlink does not automatically delete its BSO files or referenced packets
- Admin should review the `.pnt/` directory or flow files manually
- Orphaned temp files without valid flow entries will be caught by a future cleanup command
- A future cleanup command could purge orphaned BSO entries and unreferenced temp files

### 9. Flow File Corruption
**Scenario:** Power failure or crash during flow file write

**Solution:**
- `appendToFlowFile()` uses `LOCK_EX` for atomic writes
- Flow file entries reference files in `temp/` — even if flow file is corrupted, the temp files remain and can be re-migrated
- Admin can manually recreate flow files by re-running the migration script

### 10. Zone Directory Discovery
**Scenario:** System operates in multiple zones and needs to find all zone outbound directories

**Solution:**
- `hasOutboundMail()` and `scanAllOutbound()` discover zone directories by globbing for `outbound.[0-9a-f][0-9a-f][0-9a-f]` alongside the base outbound directory
- Default zone uses the unsuffixed directory name

---

## Performance Impact Analysis

### Before (Current Implementation)

**Per connection (uplink or downlink):**
- Scan ALL packets in flat directory
- Open and read header for EVERY packet
- Parse destination from EVERY header
- Check routing for EVERY packet

**I/O Operations:**
```
Total operations = N packets × M connections
Example: 100 packets × 3 uplinks = 300 file opens per polling cycle
```

### After (BSO Implementation)

**Per connection:**
- Read ONE flow file for the destination (a few KB text file)
- Check for direct BSO packet files (at most a few stat() calls)
- NO header reading needed (BSO location implies routing)
- NO destination filtering needed

**I/O Operations:**
```
Total operations per connection = 1 flow file read + stat() per referenced file
Example: 100 packets ÷ 3 uplinks ≈ 33 packets per uplink = 1 flo read + 33 stat()s
```

### Real-World Performance Scenarios

> **Note:** The improvement depends on how evenly traffic is distributed across destinations. Most FTN systems have one dominant uplink carrying 70-80% of traffic, so the real-world gain is typically 50-70% rather than the theoretical ~90% for even distribution.

**Scenario 1: Small System (typical)**
- 10 packets queued, 2 uplinks, 80/20 distribution
- Current: 20 file operations (10 × 2 connections)
- Optimized: 10 total (8 + 2, each scanned once)
- Improvement: 50% reduction

**Scenario 2: Moderate System with Points**
- 100 packets queued, 3 uplinks + 5 downlink points
- Current: 800 file operations (100 × 8 connections)
- Optimized: ~100 total (each packet scanned once from its directory)
- Improvement: 87% reduction

**Scenario 3: Busy Hub (even distribution)**
- 1000 packets queued, 5 uplinks
- Current: 5000 file operations
- Optimized: ~200 file operations
- Improvement: 96% reduction

**Scenario 4: Busy Hub (realistic skewed distribution)**
- 1000 packets queued, 5 uplinks, 70% to primary
- Current: 5000 file operations
- Optimized: ~1000 total (700 + 100 + 100 + 50 + 50)
- Improvement: 80% reduction

---

## Alternative Approaches Considered

### Option 1: Database Index
**Approach:** Create `outbound_packets` table mapping files to uplinks

**Pros:** No filesystem changes, easy to query

**Cons:** Database overhead, sync issues, added complexity

**Verdict:** Rejected - filesystem is already source of truth

### Option 2: Manifest Files
**Approach:** Maintain `uplink_<address>.manifest` files listing packets

**Pros:** Faster than header scanning

**Cons:** Manifest can get out of sync, requires file locking, corruption risk

**Verdict:** Rejected - still requires scanning, adds complexity

### Option 3: BSO (Binkley Style Outbound) (RECOMMENDED)
**Approach:** Adopt the FTN-standard BSO directory structure with zone directories, hex-encoded filenames, point subdirectories, and flow files

**Pros:**
- **Industry standard** — used by binkd, Husky, MBSE, CrashMail, and most modern FTN mailers
- **Interoperable** — enables future use of binkd alongside BinktermPHP
- Filesystem-based (no sync issues)
- Self-documenting to any FTN sysop
- Flow files decouple file creation from sending
- Naturally supports boss nodes, points, and multi-zone systems

**Cons:**
- Requires one-time migration
- More complex than simple subdirectories (zone dirs, .pnt dirs, flow files)
- Flow files add an indirection layer (file → flow entry → referenced file)

**Verdict:** RECOMMENDED — best long-term choice for interoperability and standards compliance

---

## Migration Strategy

### Phase 0: Dead Code Cleanup (Prerequisite)
**Goal:** Remove unused methods that contain flat-directory assumptions

**Steps:**
1. Remove `OutboundQueue::queueNetmail()`, `sendToUplink()`, `priorityPoll()`, `cleanupOldFiles()`, and commented-out `queueEchomail()` block
2. Remove `BinkpClient::sendFile()`
3. Commit separately

**Result:** Fewer callsites to update in Phase 1; cleaner codebase

### Phase 1: Code Deployment (Backward Compatible)
**Goal:** Deploy new code without breaking existing installations

**Steps:**
1. Add `BinkpHelper` class with BSO path resolution, flow file management, and scanning methods
2. Update `BinkdProcessor::createOutboundPacket()` to write to `temp/` and create BSO flow files
3. Update `BinkpSession::sendFiles()` to use `getFilesForDestination()` with flow file cleanup
4. Update `OutboundQueue::processOutbound()`, `getOutboundFiles()`, `getStats()` to use BSO scanning
5. Update `BinkpClient::pollAllUplinks()` to use `hasOutboundMail()`
6. Update `Scheduler::pollIfOutbound()` to use `hasOutboundMail()`
7. Deploy changes

**Result:** System works with hybrid structure, no downtime. New packets use BSO flow files; old flat `.pkt` files still found via legacy flat scan fallback.

### Phase 2: Migration Execution
**Goal:** Move existing packets into destination subdirectories

**Automatic (during upgrade):**
1. Stop mailer processes (`binkp_server` and `binkp_poll`)
2. Run `php scripts/setup.php` — upgrade.php will execute the PHP migration which calls the migration script
3. Restart mailer processes

**Manual (re-run as needed):**
```bash
php scripts/migrate_outbound_structure.php
```
This is useful after adding new uplinks/downlinks, or to re-process packets that landed in `unroutable/`.

**Result:** All flat `.pkt` and `.tic` files moved to `temp/` and referenced by BSO flow files

### Phase 3: Monitor and Verify
**Goal:** Confirm system working correctly

**Steps:**
1. Monitor packet creation (check destination subdirectories)
2. Monitor polling (check logs for successful sends from subdirectories)
3. Verify no packets stuck in unroutable/
4. If downlinks are configured, verify downlink poll-in picks up correct packets

**Duration:** 1-2 weeks of monitoring

### Phase 5: Cleanup
**Goal:** Remove legacy flat directory support

**Steps:**
1. Remove the legacy flat `glob($outboundBase . '/*.pkt')` fallback from `hasOutboundMail()`, `scanAllOutbound()`, and `sendFiles()`
2. Remove any remaining legacy destination-filtering code in `sendFiles()`
3. Clean up empty `temp/` files (files referenced by no flow file)
4. Update documentation

**Trigger:** Tie to a version bump (e.g. next minor release) rather than a time period, so the cleanup is tracked in release notes and upgrade documentation.

---

## Files Modified

### New Files Created
1. **src/BinkpHelper.php** - BSO path resolution, flow file management, outbound scanning, address conversion
2. **scripts/migrate_outbound_structure.php** - Standalone BSO migration script with lock file and TIC pair handling (re-runnable)
3. **database/migrations/vX.Y.Z_migrate_outbound_structure.php** - PHP migration that calls the script via upgrade.php

### Existing Files Modified
1. **src/BinkdProcessor.php** - Update `createOutboundPacket()` to write to `temp/` and create BSO flow file entries
2. **src/Binkp/Protocol/BinkpSession.php** - Update `sendFiles()` to use `BinkpHelper::getFilesForDestination()` with flow file cleanup; add answerer-mode send support for downlinks
3. **src/Binkp/Queue/OutboundQueue.php** - Update `processOutbound()`, `getOutboundFiles()`, `getStats()` to use BSO scanning
4. **src/Binkp/Protocol/BinkpClient.php** - Update `pollAllUplinks()` to use `BinkpHelper::hasOutboundMail()`
5. **src/Binkp/Connection/Scheduler.php** - Update `pollIfOutbound()` to use `BinkpHelper::hasOutboundMail()`
6. **src/Binkp/Config/BinkpConfig.php** - Add `isDownlinkAddress()` and `getDefaultZone()` methods

### Configuration Files
- **No changes required** - Uses existing `outbound_path` from `config/binkp.json`

### Dependencies

1. **Downlink Support:** This proposal references `isDownlinkAddress()` on `BinkpConfig`, which depends on the downlink/point node support feature (separate proposal). If implemented before downlinks exist, the method should return `false` unconditionally and be updated when downlink support lands.

2. **Default Zone Configuration:** BSO requires knowing the default zone (for unsuffixed outbound directory). `BinkpConfig::getDefaultZone()` must be added — it can be derived from the system's primary AKA address or configured explicitly in `binkp.json`.

### Dead Code Cleanup (Prerequisite)

The following unused methods should be removed in a separate commit before or alongside this work. They contain flat-directory assumptions that would otherwise need updating for no benefit:

**`src/Binkp/Queue/OutboundQueue.php`:**
- `queueNetmail()` — never called anywhere
- `sendToUplink()` — only called by `priorityPoll()`
- `priorityPoll()` — never called externally
- `cleanupOldFiles()` — never called anywhere
- Commented-out `queueEchomail()` + `getEchoareaUplink()` block (marked `/* XXX: Not used */`)

**`src/Binkp/Protocol/BinkpClient.php`:**
- `sendFile()` — never called anywhere

---

## Testing and Verification

### Unit Tests

Test `BinkpHelper` BSO methods:
- `parseAddress()` — valid addresses parse correctly, invalid throw exceptions
- `getZoneDir()` — default zone returns base path, other zones return suffixed path
- `getNodeBase()` — net/node to hex conversion
- `getBsoFileBase()` — boss nodes vs points
- `bsoPathToAddress()` — round-trip conversion from BSO path back to address
- `getOutboundPathForAddress()` — routing through uplinks, downlinks, unroutable
- Flow file operations — append, read, remove entries

### Integration Tests

1. **Packet Creation:** Verify new packets appear in `temp/` and flow files created in correct BSO locations
2. **Point Handling:** Verify point addresses create `.pnt/` subdirectories with correct hex filenames
3. **Zone Handling:** Verify non-default zones create `outbound.ZZZ/` directories
4. **Unroutable Packets:** Verify packets with no route go to `unroutable/`
5. **Polling:** Verify `getFilesForDestination()` returns correct files for a session
6. **Flow File Cleanup:** Verify sent files are deleted and flow entries removed
7. **Migration:** Verify script moves flat `.pkt` files to `temp/` and creates flow entries

### Manual Verification

```bash
# Check BSO directory structure
ls -la data/outbound/
ls -la data/outbound/*.flo 2>/dev/null
ls -la data/outbound/*.pnt/ 2>/dev/null

# View flow file contents
cat data/outbound/00990095.flo

# Check temp directory
ls -la data/outbound/temp/

# Run migration
php scripts/migrate_outbound_structure.php

# Test polling
php scripts/binkp_poll.php 1:153/149
```

---

## Rollback Plan

If critical issues arise:

1. **Revert code changes**
2. **Move packets back to flat directory:**
   ```bash
   # Move all temp packets back to flat outbound
   mv data/outbound/temp/*.pkt data/outbound/ 2>/dev/null
   mv data/outbound/temp/*.tic data/outbound/ 2>/dev/null
   # Remove BSO files (flow files, zone dirs, .pnt dirs)
   rm -f data/outbound/*.flo data/outbound/*.out
   rm -rf data/outbound/*.pnt data/outbound/temp
   rm -rf data/outbound.[0-9a-f][0-9a-f][0-9a-f]
   ```
3. **Restart services**
4. **Verify functionality**

**Recovery Time:** 15-30 minutes

---

## Timeline and Effort Estimate

### Development Phase
- **BinkpHelper class:** 30 minutes
- **Update BinkdProcessor:** 45 minutes
- **Update BinkpSession:** 1 hour
- **Migration script:** 1 hour
- **Total Development:** ~3 hours

### Testing Phase
- **Unit tests:** 30 minutes
- **Integration tests:** 1 hour
- **Manual testing:** 1 hour
- **Total Testing:** ~2.5 hours

### Documentation Phase
- **Code documentation:** 30 minutes
- **User documentation:** 30 minutes
- **Total Documentation:** ~1 hour

### Deployment Phase
- **Code deployment:** 15 minutes
- **Migration execution:** 15 minutes
- **Verification:** 30 minutes
- **Total Deployment:** ~1 hour

**Grand Total:** ~7.5 hours

---

## Success Criteria

1. ✅ **Functional Requirements Met:**
   - New packets written to `temp/` and referenced by BSO flow files
   - Zone directories and `.pnt/` subdirectories created correctly
   - Polling uses `getFilesForDestination()` to read flow files
   - Unroutable packets go to `unroutable/` directory
   - Legacy flat packets still processed during transition

2. ✅ **Performance Targets Achieved:**
   - 80%+ reduction in file I/O operations
   - Faster polling times
   - No increase in CPU or memory usage

3. ✅ **Reliability:**
   - No packet loss during migration
   - All packets eventually transmitted
   - No regression in delivery success rate

4. ✅ **Maintainability:**
   - Code documented with phpDoc blocks
   - User documentation complete
   - Migration path clear

---

## Conclusion

This proposal provides a comprehensive plan for adopting the Binkley Style Outbound (BSO) directory structure, the FTN standard used by binkd and other modern mailers. The implementation delivers significant performance improvements, enables future interoperability with other BSO-aware software, and provides a foundation for both uplink and downlink support.

**Key Benefits:**
- 50-70% reduction in file I/O for typical installations (up to ~90% on busy hubs)
- **BSO-standard** layout compatible with binkd, Husky, MBSE, and other FTN mailers
- Flow files decouple file creation from sending, enabling future features
- Unified scheme for uplinks, downlinks, points, and multi-zone systems
- Easier troubleshooting — any FTN sysop can inspect the standard directory layout
- Centralized BSO operations via `BinkpHelper` class
- Dead code cleanup removes 6 unused methods

**Recommendation:** Proceed with implementation following the phased approach outlined above. Start with Phase 0 (dead code cleanup) to reduce the scope of changes. If downlink support has not yet landed, implement `isDownlinkAddress()` as a stub returning `false` and update it when the downlink feature is ready.

---

**Document Version:** 1.3 Draft
**Last Updated:** 2026-02-14
**Author:** AI-Generated (Claude)
**Status:** Proposal - Revised to adopt full BSO (Binkley Style Outbound) with flow files, complete callsite audit, dead code cleanup, downlink support, realistic performance estimates, TIC pair handling, migration safety
