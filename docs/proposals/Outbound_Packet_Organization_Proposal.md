# Outbound Packet Organization by Destination - Implementation Proposal

**DRAFT DOCUMENT - Generated by AI - May not have been reviewed for accuracy**

**Status:** DRAFT
**Generated:** 2026-02-02
**Revised:** 2026-02-14
**Version:** 1.1

---

## ⚠️ Disclaimer

This proposal is a **draft** and was **generated by AI**. It may not have been reviewed for accuracy or completeness. All architectural decisions, implementation details, and performance claims should be reviewed and verified by the development team before implementation.

---

## Executive Summary

This proposal outlines a filesystem reorganization strategy to improve the efficiency of outbound packet processing in BinktermPHP's binkp mailer. The current implementation scans all packets in a flat directory structure for every connection, resulting in unnecessary I/O overhead. This proposal introduces destination-specific subdirectories — for both uplinks (nodes we call out to) and downlinks (nodes that call in to us, e.g. point systems) — to reduce file operations significantly.

### Key Objectives

- Organize outbound packets into destination-specific subdirectories (uplinks and downlinks)
- Reduce file I/O operations during packet scanning
- Improve polling efficiency and performance
- Support downlink/point node outbound queuing
- Maintain backward compatibility during migration
- Provide clear admin tools for packet management

### Expected Benefits

- **Performance:** 50-70% reduction in file I/O operations for typical installations (up to ~90% on busy hubs with evenly distributed traffic)
- **Clarity:** Easy to see which packets are queued for which destination
- **Debugging:** Simplified troubleshooting and inspection
- **Scalability:** Performance scales better with packet count and destination count
- **Downlink support:** Packets for point nodes are pre-sorted into per-address directories, making inbound polling sessions fast

---

## Problem Statement

### Current Implementation

When `binkp_poll` connects to an uplink, it performs the following operations:

1. Scans ALL packets in `data/outbound/*.pkt`
2. Opens EACH packet file and reads its header (58 bytes)
3. Parses the destination address from the header
4. Checks if the destination routes through the current uplink
5. Sends only matching packets

**Performance Impact:**
- 100 packets queued across 3 uplinks = 300 file open operations per polling cycle
- Each uplink connection reads headers for packets destined for OTHER uplinks
- Wasted I/O grows linearly with both packet count and uplink count

### Code Location

**File:** `src/Binkp/Protocol/BinkpSession.php`
**Method:** `sendFiles()` (starts at line ~643)

```php
// Current implementation (simplified)
$pktFiles = glob($outboundPath . '/*.pkt');

foreach ($files as $file) {
    if ($this->currentUplink !== null) {
        $destAddr = $this->getPacketDestination($file);  // Opens and reads header
        if (!$this->config->isDestinationForUplink($destAddr, $this->currentUplink)) {
            continue;  // Skip packet - wasted I/O
        }
    }
    $filesToSend[] = $file;
}
```

### Downlink Gap

The current implementation has no concept of outbound queuing for downlinks (nodes that call *in* to us). When a downlink polls in, there is no efficient way to find packets addressed to it. The proposed directory structure solves this for both uplinks and downlinks.

---

## Proposed Solution

### Overview

Organize outbound packets into destination-specific subdirectories based on the destination's FidoNet address converted to a hex identifier. This applies to both uplinks and downlinks. When connecting to (or receiving a poll from) a destination, scan only its dedicated subdirectory.

**Efficiency Gain:**
- 100 packets across 3 uplinks + 2 downlinks → ~20 packets per directory
- Each connection reads only relevant packets
- 50-70% reduction for typical installations; up to ~90% on busy hubs

### Directory Structure

#### Hex ID Format

Convert FidoNet addresses to hex-encoded subdirectory names:

```
Zone:Net/Node.Point → hex(Zone)_hex(Net)_hex(Node)_hex(Point)
```

**Examples:**
```
1:153/149.0    → 0001_0099_0095_0000
21:1/100.0     → 0015_0001_0064_0000
99:22/44.5     → 0063_0016_002c_0005
1:123/456      → 0001_007b_01c8_0000  (point defaults to 0)
```

**Format Rationale:**
- **Fixed-width hex** (4 digits per component) ensures consistent directory names
- **Underscore separators** improve human readability
- **Includes point number** (default 0) for completeness and future compatibility
- **No collisions possible** - 1:1 mapping with FTN addresses
- **Filesystem-safe** - no special characters, works on Windows/Unix/Mac

#### Proposed Directory Layout

```
data/outbound/
├── 0001_0099_0095_0000/        # Packets for uplink 1:153/149
│   ├── a1b2c3d4.pkt
│   ├── e5f6a7b8.pkt
│   └── f9a0b1c2.tic
├── 0015_0001_0064_0000/        # Packets for uplink 21:1/100
│   ├── c9d0e1f2.pkt
│   └── d3e4f5a6.pkt
├── 0001_007b_01c8_0001/        # Packets for downlink point 1:123/456.1
│   └── b7c8d9e0.pkt
├── unroutable/                 # Fallback for packets with no route
│   └── deadletter.pkt
└── (legacy *.pkt files during migration)
```

**Note:** Uplinks and downlinks share the same directory scheme. A directory is created by converting the **destination address** to hex — for uplinks this is the uplink's address, for downlinks this is the point node's address. Since FTN addresses are unique, there is no collision risk.

---

## Implementation Plan

### Phase 1: Add Hex Conversion Utility

**File:** `src/BinkpHelper.php` (new file)

Create a new helper class with static methods for address conversion:

```php
<?php

namespace BinktermPHP;

/**
 * Helper utilities for Binkp protocol operations.
 */
class BinkpHelper
{
    /**
     * Convert FidoNet address to hex-based directory name.
     *
     * @param string $address Format: "Zone:Net/Node.Point" or "Zone:Net/Node"
     * @return string Hex directory name (e.g., "0001_0099_0095_0000")
     * @throws \InvalidArgumentException If address format is invalid
     */
    public static function addressToHexDir(string $address): string
    {
        // Parse: 1:153/149.0 or 1:153/149
        if (!preg_match('/^(\d+):(\d+)\/(\d+)(?:\.(\d+))?$/', $address, $m)) {
            throw new \InvalidArgumentException("Invalid FTN address: $address");
        }

        $zone = str_pad(dechex((int)$m[1]), 4, '0', STR_PAD_LEFT);
        $net = str_pad(dechex((int)$m[2]), 4, '0', STR_PAD_LEFT);
        $node = str_pad(dechex((int)$m[3]), 4, '0', STR_PAD_LEFT);
        $point = str_pad(dechex((int)($m[4] ?? 0)), 4, '0', STR_PAD_LEFT);

        return "{$zone}_{$net}_{$node}_{$point}";
    }

    /**
     * Convert hex directory name back to FidoNet address.
     *
     * @param string $hexDir Format: "0001_0099_0095_0000"
     * @return string FidoNet address (e.g., "1:153/149.0" or "1:153/149")
     * @throws \InvalidArgumentException If hex directory format is invalid
     */
    public static function hexDirToAddress(string $hexDir): string
    {
        $parts = explode('_', $hexDir);
        if (count($parts) !== 4) {
            throw new \InvalidArgumentException("Invalid hex directory: $hexDir");
        }

        $zone = hexdec($parts[0]);
        $net = hexdec($parts[1]);
        $node = hexdec($parts[2]);
        $point = hexdec($parts[3]);

        return $point > 0 ? "$zone:$net/$node.$point" : "$zone:$net/$node";
    }

    /**
     * Get the outbound directory path for a given destination address.
     *
     * Resolves the destination to either an uplink (via routing table) or
     * treats it as a direct destination (e.g. a downlink/point node), converts
     * to a hex subdirectory, creates it if needed, and returns the full path.
     *
     * For uplink-routed destinations, the directory is keyed to the uplink's
     * address (since all packets for that uplink share a directory). For
     * downlink/point destinations with no uplink route, the directory is keyed
     * to the destination address itself.
     *
     * @param string $destAddr Destination FTN address (e.g., "1:123/456.1")
     * @param string $outboundBase Base outbound directory path
     * @param BinkpConfig|null $config Optional config for uplink route lookup
     * @return string Full path to the destination's outbound subdirectory
     */
    public static function getOutboundPathForAddress(
        string $destAddr,
        string $outboundBase,
        ?Config\BinkpConfig $config = null
    ): string {
        $config = $config ?: Config\BinkpConfig::getInstance();

        // Try to route through an uplink first
        $uplink = $config->getUplinkForDestination($destAddr);

        if ($uplink) {
            // Packets routed through an uplink go in the uplink's directory
            $hexDir = self::addressToHexDir($uplink['address']);
        } elseif ($config->isDownlinkAddress($destAddr)) {
            // Downlink/point node — use the destination address directly
            $hexDir = self::addressToHexDir($destAddr);
        } else {
            // No route and not a known downlink — unroutable
            $path = $outboundBase . '/unroutable';
            if (!is_dir($path)) {
                mkdir($path, 0755, true);
            }
            return $path;
        }

        $path = $outboundBase . '/' . $hexDir;
        if (!is_dir($path)) {
            mkdir($path, 0755, true);
        }
        return $path;
    }
}
```

**Note:** `getOutboundPathForAddress()` centralises the routing-to-directory logic so that both `BinkdProcessor::createOutboundPacket()` and future downlink broadcasting code share the same path resolution. The method handles three cases:

1. **Uplink-routed** — destination matches an uplink's network patterns → directory keyed to uplink address
2. **Downlink** — destination is a registered downlink/point node → directory keyed to the point's own address
3. **Unroutable** — no route and not a downlink → `unroutable/` fallback

### Phase 2: Update Packet Creation

**File:** `src/BinkdProcessor.php`
**Method:** `createOutboundPacket()`

**Changes Required:**

1. Use `BinkpHelper::getOutboundPathForAddress()` to determine the correct subdirectory
2. The `$destAddr` parameter already present in the method signature is the packet header's destination address — this is the address used for routing
3. Auto-create subdirectories as needed
4. Log a warning for unroutable packets

**Important distinction:** The `$destAddr` parameter represents the packet's header destination (the final recipient). For uplink routing, this address is matched against uplink network patterns to determine *which uplink* carries the packet. The directory is keyed to the **uplink's address**, not the final destination. For downlinks, the directory is keyed to the **destination address itself** since we deliver directly. This distinction is handled by `getOutboundPathForAddress()`.

**Implementation:**

```php
public function createOutboundPacket($messages, $destAddr, $outputPath = null)
{
    // If outputPath explicitly provided, use it (backward compatibility)
    if ($outputPath !== null) {
        $filename = $outputPath;
    } else {
        // Use centralized routing to determine outbound subdirectory
        $targetDir = BinkpHelper::getOutboundPathForAddress($destAddr, $this->outboundPath);

        if (basename($targetDir) === 'unroutable') {
            $this->log("[BINKD] WARNING: No route found for destination $destAddr - packet queued in unroutable/");
        }

        $filename = $targetDir . '/' . substr(uniqid(), -8) . '.pkt';
    }

    $packetName = basename($filename);
    $handle = fopen($filename, 'wb');

    // Rest of function remains unchanged...
}
```

**Backward Compatibility:**
- Explicit `$outputPath` parameter still honored (used by tests and special cases)
- No breaking changes to method signature

### Phase 3: Update Packet Scanning

**File:** `src/Binkp/Protocol/BinkpSession.php`
**Method:** `sendFiles()` (starts at line ~643)

**Changes Required:**

1. Determine the hex directory for the current session's destination:
   - **Uplink sessions (originator):** use `BinkpHelper::addressToHexDir($this->currentUplink['address'])`
   - **Downlink sessions (answerer):** use `BinkpHelper::addressToHexDir($this->remoteAddress)` (the downlink's own address)
2. Scan destination-specific subdirectory first
3. Fall back to flat directory scan for legacy packets (migration support)
4. Skip destination filtering for packets from destination directories
5. Maintain destination filtering for legacy flat packets

**Implementation approach:**

- Determine hex dir from session context (uplink address or downlink address)
- Scan destination directory: `data/outbound/<hex_dir>/*.pkt`
- Also scan flat directory for legacy packets during migration period
- Mark packets from destination directory as "pre-filtered" (skip destination check)
- Mark packets from flat directory as "legacy" (need destination filtering)
- Process and send appropriately

**Answerer-mode note:** Currently `sendFiles()` is only called in the originator branch of `processSession()`. For downlink support, `sendFiles()` must also be called in the answerer branch when the remote is a downlink. This is a separate change tracked in the downlink/point node support proposal, but the directory structure defined here supports it.

### Phase 4: Update TIC File Handling

**Same file:** `src/Binkp/Protocol/BinkpSession.php`

TIC files (file transfer metadata) come in pairs: a `.tic` metadata file and its associated data file. Both files must be placed in the same destination subdirectory.

**Key considerations:**
- The data file's destination is not encoded in its filename — it is specified by the `To` field inside the `.tic` metadata file
- When creating a TIC pair, the routing destination should be derived from the `To` field in the `.tic` file, then both files placed in the corresponding hex subdirectory
- When scanning for outbound TIC pairs, scan the destination subdirectory just like packet files
- During migration, the migration script must parse the `To` field from each `.tic` file and move both the `.tic` and its associated data file (identified by the `File` field) to the correct subdirectory together

**Implementation:**
- Created in destination subdirectories alongside data files
- Scanned from destination subdirectories during polling
- Legacy flat TIC files supported during migration
- Migration script must handle TIC pairs atomically (move both files or neither)

### Phase 5: Migration Script

**File:** `scripts/migrate_outbound_structure.php` (new file)

Create a CLI script to migrate existing flat packets into destination subdirectories.

**Race condition warning:** If `binkp_poll` or `binkp_server` runs while migration is in progress, a packet could be missed or double-sent. The migration script must acquire an exclusive lock before moving files, and the mailer should be stopped during migration. The script should enforce this.

```php
#!/usr/bin/env php
<?php

require __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/../src/functions.php';

use BinktermPHP\Binkp\Config\BinkpConfig;
use BinktermPHP\BinkpHelper;

$config = BinkpConfig::getInstance();
$outboundPath = $config->getOutboundPath();

echo "=== Outbound Directory Migration ===\n\n";
echo "Outbound path: $outboundPath\n\n";

// Acquire exclusive lock to prevent concurrent mailer access
$lockFile = $outboundPath . '/.migration.lock';
$lockHandle = fopen($lockFile, 'w');
if (!flock($lockHandle, LOCK_EX | LOCK_NB)) {
    echo "ERROR: Cannot acquire lock - another migration or mailer may be running.\n";
    echo "Stop binkp_server and binkp_poll before running migration.\n";
    exit(1);
}

echo "WARNING: Ensure binkp_server and binkp_poll are stopped before proceeding.\n";
echo "Press Enter to continue or Ctrl+C to abort...\n";
fgets(STDIN);

// Scan for flat packets and TIC files
$flatPackets = glob($outboundPath . '/*.pkt') ?: [];
$flatTics = glob($outboundPath . '/*.tic') ?: [];
echo "Found " . count($flatPackets) . " packets and " . count($flatTics) . " TIC files in flat directory\n\n";

if (empty($flatPackets) && empty($flatTics)) {
    echo "No files to migrate!\n";
    flock($lockHandle, LOCK_UN);
    fclose($lockHandle);
    @unlink($lockFile);
    exit(0);
}

$moved = 0;
$failed = 0;
$unroutable = 0;

foreach ($flatPackets as $packet) {
    $basename = basename($packet);
    echo "Processing: $basename ... ";

    // Read packet header to get destination
    $handle = fopen($packet, 'rb');
    if (!$handle) {
        echo "FAILED (cannot open)\n";
        $failed++;
        continue;
    }

    $header = fread($handle, 58);
    fclose($handle);

    if (strlen($header) < 58) {
        echo "FAILED (invalid header)\n";
        $failed++;
        continue;
    }

    // Parse destination address from packet header (including point)
    $data = unpack('vorigNode/vdestNode', substr($header, 0, 4));
    $netData = unpack('vorigNet/vdestNet', substr($header, 20, 4));

    $destZone = 1;
    if (strlen($header) >= 38) {
        $zoneData = unpack('vdestZone', substr($header, 36, 2));
        $destZone = $zoneData['destZone'] ?? 1;
    }

    // Read destPoint from FSC-39 (Type-2e) offset 30-31
    $destPoint = 0;
    if (strlen($header) >= 32) {
        $pointData = unpack('vdestPoint', substr($header, 30, 2));
        $destPoint = $pointData['destPoint'] ?? 0;
    }

    $destAddr = $destZone . ':' . $netData['destNet'] . '/' . $data['destNode'];
    if ($destPoint > 0) {
        $destAddr .= '.' . $destPoint;
    }

    // Use centralized routing to determine target directory
    $targetDir = BinkpHelper::getOutboundPathForAddress($destAddr, $outboundPath, $config);
    $dirLabel = basename($targetDir);
    $targetPath = $targetDir . '/' . $basename;

    if (rename($packet, $targetPath)) {
        if ($dirLabel === 'unroutable') {
            echo "UNROUTABLE (moved to unroutable/)\n";
            $unroutable++;
        } else {
            echo "OK (moved to $dirLabel/)\n";
            $moved++;
        }
    } else {
        echo "FAILED (cannot move)\n";
        $failed++;
    }
}

// Migrate TIC pairs (tic + data file together)
foreach ($flatTics as $ticFile) {
    $ticBasename = basename($ticFile);
    echo "Processing TIC: $ticBasename ... ";

    $ticContent = @file_get_contents($ticFile);
    if ($ticContent === false) {
        echo "FAILED (cannot read)\n";
        $failed++;
        continue;
    }

    // Parse To and File fields
    $destAddr = null;
    $dataFilename = null;
    foreach (explode("\n", $ticContent) as $line) {
        $line = trim($line);
        if (preg_match('/^To\s+(.+)$/i', $line, $m)) $destAddr = trim($m[1]);
        if (preg_match('/^File\s+(.+)$/i', $line, $m)) $dataFilename = trim($m[1]);
    }

    if (!$destAddr) {
        echo "FAILED (no To field)\n";
        $failed++;
        continue;
    }

    $targetDir = BinkpHelper::getOutboundPathForAddress($destAddr, $outboundPath, $config);
    $dirLabel = basename($targetDir);

    // Move data file first (if it exists), then TIC file
    $dataOk = true;
    if ($dataFilename) {
        $dataPath = dirname($ticFile) . '/' . $dataFilename;
        if (file_exists($dataPath)) {
            if (!rename($dataPath, $targetDir . '/' . $dataFilename)) {
                echo "FAILED (cannot move data file)\n";
                $failed++;
                $dataOk = false;
            }
        }
    }

    if ($dataOk) {
        if (rename($ticFile, $targetDir . '/' . $ticBasename)) {
            echo "OK (moved to $dirLabel/)\n";
            $moved++;
        } else {
            echo "FAILED (cannot move TIC)\n";
            $failed++;
        }
    }
}

// Release lock
flock($lockHandle, LOCK_UN);
fclose($lockHandle);
@unlink($lockFile);

echo "\n=== Migration Complete ===\n";
echo "Successfully moved: $moved\n";
echo "Unroutable: $unroutable\n";
echo "Failed: $failed\n";

if ($failed > 0) {
    exit(1);
}

exit(0);
```

---

## Edge Cases and Error Handling

### 1. No Route Found
**Scenario:** Packet created for destination with no configured uplink and destination is not a registered downlink

**Solution:**
- Create packet in `data/outbound/unroutable/` subdirectory
- Log warning message with destination address
- Admin can review unroutable/ directory periodically

### 2. Uplink Configuration Changes
**Scenario:** Uplink address changes after packets are queued

**Solution:**
- Re-run migration script to reorganize all packets
- Document that changing uplink addresses requires migration

### 3. Downlink Added After Packets Queued
**Scenario:** Echomail packets for a point address were created before that point was registered as a downlink, so they landed in `unroutable/`

**Solution:**
- Re-run migration script — it will now find a downlink match and move them to the correct directory
- Alternatively, the admin can manually move files from `unroutable/` to the correct hex directory

### 4. Multiple Uplinks for Same Destination
**Scenario:** Broadcast packets or load balancing

**Current Behavior:**
- `getUplinkForDestination()` returns first matching uplink
- Packet placed in first uplink's directory only

**Limitation Accepted:** First match wins (consistent with current routing logic)

### 5. Packet Destination Parsing Failures
**Solution:**
- Leave packet in flat directory (not moved during migration)
- Log error with packet filename
- Admin can manually inspect and fix/delete

### 6. Filesystem Permission Issues
**Solution:**
- Log error and continue processing other packets
- Migration script exits with error code if any failures
- Admin must fix permissions and re-run

### 7. Concurrent Mailer Access During Migration
**Scenario:** `binkp_poll` or `binkp_server` runs while migration script is moving files

**Risk:** Packet could be missed (moved after scan, before send) or double-sent (sent from flat dir, then sent again from subdirectory)

**Solution:**
- Migration script acquires an exclusive file lock
- Script warns operator to stop mailer processes before proceeding
- Uses `rename()` which is atomic on the same filesystem

### 8. Downlink Deleted While Packets Queued
**Scenario:** Admin deletes a downlink that still has packets in its outbound directory

**Solution:**
- Deleting a downlink does not automatically delete its outbound directory or packets
- Admin should review the directory manually, or the packets will be ignored (no session will claim them)
- A future cleanup command could purge orphaned directories

---

## Performance Impact Analysis

### Before (Current Implementation)

**Per connection (uplink or downlink):**
- Scan ALL packets in flat directory
- Open and read header for EVERY packet
- Parse destination from EVERY header
- Check routing for EVERY packet

**I/O Operations:**
```
Total operations = N packets × M connections
Example: 100 packets × 3 uplinks = 300 file opens per polling cycle
```

### After (Optimized Implementation)

**Per connection:**
- Scan ONLY destination-specific subdirectory
- NO header reading needed (directory implies routing)
- NO destination filtering needed

**I/O Operations:**
```
Total operations per connection = only packets in that directory
Example: 100 packets ÷ 3 uplinks ≈ 33 packets per uplink = 33 file operations
```

### Real-World Performance Scenarios

> **Note:** The improvement depends on how evenly traffic is distributed across destinations. Most FTN systems have one dominant uplink carrying 70-80% of traffic, so the real-world gain is typically 50-70% rather than the theoretical ~90% for even distribution.

**Scenario 1: Small System (typical)**
- 10 packets queued, 2 uplinks, 80/20 distribution
- Current: 20 file operations (10 × 2 connections)
- Optimized: 10 total (8 + 2, each scanned once)
- Improvement: 50% reduction

**Scenario 2: Moderate System with Points**
- 100 packets queued, 3 uplinks + 5 downlink points
- Current: 800 file operations (100 × 8 connections)
- Optimized: ~100 total (each packet scanned once from its directory)
- Improvement: 87% reduction

**Scenario 3: Busy Hub (even distribution)**
- 1000 packets queued, 5 uplinks
- Current: 5000 file operations
- Optimized: ~200 file operations
- Improvement: 96% reduction

**Scenario 4: Busy Hub (realistic skewed distribution)**
- 1000 packets queued, 5 uplinks, 70% to primary
- Current: 5000 file operations
- Optimized: ~1000 total (700 + 100 + 100 + 50 + 50)
- Improvement: 80% reduction

---

## Alternative Approaches Considered

### Option 1: Database Index
**Approach:** Create `outbound_packets` table mapping files to uplinks

**Pros:** No filesystem changes, easy to query

**Cons:** Database overhead, sync issues, added complexity

**Verdict:** Rejected - filesystem is already source of truth

### Option 2: Manifest Files
**Approach:** Maintain `uplink_<address>.manifest` files listing packets

**Pros:** Faster than header scanning

**Cons:** Manifest can get out of sync, requires file locking, corruption risk

**Verdict:** Rejected - still requires scanning, adds complexity

### Option 3: Hex Subdirectories (RECOMMENDED)
**Approach:** Organize packets into destination-specific subdirectories (uplinks and downlinks)

**Pros:**
- Self-documenting (directory name shows destination address)
- Filesystem-based (no sync issues)
- Standard approach in FTN mail systems (similar to Binkd's BSO outbound)
- Easy to inspect and troubleshoot
- Naturally supports both uplinks and downlinks with a single scheme

**Cons:**
- Requires one-time migration
- Slightly more complex directory structure

**Verdict:** RECOMMENDED - best balance of simplicity, performance, and maintainability

---

## Migration Strategy

### Phase 1: Code Deployment (Backward Compatible)
**Goal:** Deploy new code without breaking existing installations

**Steps:**
1. Add `BinkpHelper` class
2. Update `BinkdProcessor::createOutboundPacket()` to use destination directories
3. Update `BinkpSession::sendFiles()` to scan BOTH destination directories AND flat directory
4. Deploy changes

**Result:** System works with hybrid structure, no downtime. New packets go to subdirectories; old packets still found via flat scan.

### Phase 2: Migration Execution
**Goal:** Move existing packets into destination subdirectories

**Steps:**
1. **Stop mailer processes** (`binkp_server` and `binkp_poll`)
2. Run migration script:
   ```bash
   php scripts/migrate_outbound_structure.php
   ```
3. Verify migration completed successfully (check exit code and output)
4. Restart mailer processes
5. Test polling each uplink

**Result:** All packets organized by destination

### Phase 3: Monitor and Verify
**Goal:** Confirm system working correctly

**Steps:**
1. Monitor packet creation (check destination subdirectories)
2. Monitor polling (check logs for successful sends from subdirectories)
3. Verify no packets stuck in unroutable/
4. If downlinks are configured, verify downlink poll-in picks up correct packets

**Duration:** 1-2 weeks of monitoring

### Phase 4: Cleanup
**Goal:** Remove legacy flat directory support

**Steps:**
1. Remove flat directory scanning from `sendFiles()`
2. Simplify code
3. Update documentation

**Trigger:** Tie to a version bump (e.g. next minor release) rather than a time period, so the cleanup is tracked in release notes and upgrade documentation.

---

## Files Modified

### New Files Created
1. **src/BinkpHelper.php** - Address conversion utilities and centralized outbound path resolution
2. **scripts/migrate_outbound_structure.php** - Migration script with lock file and TIC pair handling

### Existing Files Modified
1. **src/BinkdProcessor.php** - Update `createOutboundPacket()` to use `BinkpHelper::getOutboundPathForAddress()`
2. **src/Binkp/Protocol/BinkpSession.php** - Update `sendFiles()` to scan destination subdirectories; add answerer-mode send support for downlinks
3. **src/Binkp/Config/BinkpConfig.php** - Add `isDownlinkAddress()` method (required by `BinkpHelper::getOutboundPathForAddress()`)

### Configuration Files
- **No changes required** - Uses existing `outbound_path` from `config/binkp.json`

### Dependency on Downlink Support
This proposal references `isDownlinkAddress()` on `BinkpConfig`, which depends on the downlink/point node support feature (separate proposal). If implemented before downlinks exist, the method should return `false` unconditionally and be updated when downlink support lands.

---

## Testing and Verification

### Unit Tests

Test `BinkpHelper` address conversion:
- Valid addresses convert correctly
- Round-trip conversion works
- Invalid addresses throw exceptions

### Integration Tests

1. **Packet Creation:** Verify new packets appear in correct uplink subdirectories
2. **Unroutable Packets:** Verify packets with no route go to unroutable/
3. **Polling:** Verify scanning works with uplink subdirectories
4. **Migration:** Verify script moves packets correctly

### Manual Verification

```bash
# Check directory structure
ls -la data/outbound/

# Count packets per uplink
for dir in data/outbound/*/; do
    count=$(ls -1 "$dir"/*.pkt 2>/dev/null | wc -l)
    echo "$dir: $count packets"
done

# Run migration
php scripts/migrate_outbound_structure.php

# Test polling
php scripts/binkp_poll.php 1:153/149
```

---

## Rollback Plan

If critical issues arise:

1. **Revert code changes**
2. **Move packets back to flat directory:**
   ```bash
   find data/outbound -name "*.pkt" -type f -exec mv {} data/outbound/ \;
   find data/outbound -type d -empty -delete
   ```
3. **Restart services**
4. **Verify functionality**

**Recovery Time:** 15-30 minutes

---

## Timeline and Effort Estimate

### Development Phase
- **BinkpHelper class:** 30 minutes
- **Update BinkdProcessor:** 45 minutes
- **Update BinkpSession:** 1 hour
- **Migration script:** 1 hour
- **Total Development:** ~3 hours

### Testing Phase
- **Unit tests:** 30 minutes
- **Integration tests:** 1 hour
- **Manual testing:** 1 hour
- **Total Testing:** ~2.5 hours

### Documentation Phase
- **Code documentation:** 30 minutes
- **User documentation:** 30 minutes
- **Total Documentation:** ~1 hour

### Deployment Phase
- **Code deployment:** 15 minutes
- **Migration execution:** 15 minutes
- **Verification:** 30 minutes
- **Total Deployment:** ~1 hour

**Grand Total:** ~7.5 hours

---

## Success Criteria

1. ✅ **Functional Requirements Met:**
   - New packets created in uplink subdirectories
   - Polling scans uplink subdirectories
   - Unroutable packets go to unroutable/ directory
   - Legacy flat packets still processed during transition

2. ✅ **Performance Targets Achieved:**
   - 80%+ reduction in file I/O operations
   - Faster polling times
   - No increase in CPU or memory usage

3. ✅ **Reliability:**
   - No packet loss during migration
   - All packets eventually transmitted
   - No regression in delivery success rate

4. ✅ **Maintainability:**
   - Code documented with phpDoc blocks
   - User documentation complete
   - Migration path clear

---

## Conclusion

This proposal provides a comprehensive plan for organizing outbound packets by destination, delivering significant performance improvements while maintaining backward compatibility. The implementation is straightforward, consistent with how other FTN mailers (Binkd BSO) organize outbound mail, and provides a foundation for both uplink and downlink support.

**Key Benefits:**
- 50-70% reduction in file I/O for typical installations (up to ~90% on busy hubs)
- Unified directory scheme for uplinks and downlinks
- Easier troubleshooting and debugging
- Better separation of concerns
- Centralized path resolution via `BinkpHelper::getOutboundPathForAddress()`

**Recommendation:** Proceed with implementation following the phased approach outlined above. If downlink support has not yet landed, implement `isDownlinkAddress()` as a stub returning `false` and update it when the downlink feature is ready.

---

**Document Version:** 1.1 Draft
**Last Updated:** 2026-02-14
**Author:** AI-Generated (Claude)
**Status:** Proposal - Revised with downlink support, realistic performance estimates, TIC pair handling, migration safety
